<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Городской гид - {{title}}</title>
    <!-- Подключение CSS файла -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/PersonalPage.css') }}">
    <!-- Украшаем вкладку вашим логотипом -->
    <link rel="icon" href="{{ url_for('static', filename='Фотки зданий/лого.png') }}" type="image/png">

    <script src="{{ url_for('static', filename='js/RegistrationLogin.js') }}"></script>
</head>
<script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"></script>

<body>
    <!-- Объединенная навигация -->
<nav class="navbar">
    <div class="nav-container">
        <div class="logo" onclick="window.location.href='/';">
            <img src="{{ url_for('static', filename='Фотки зданий/лого.png') }}" alt="Логотип" height="50px" width="70px">
            <span>Городской Гид</span>
        </div>

        <!-- Поиск из старого HTML с визуалом нового -->
        <form class="search-box" action="/search" method="POST">
            <input type="text" name="query" placeholder="Поиск заведений..." class="search-input" id="search-input">
            <button type="submit" class="search-button">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M21 21L16.65 16.65" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </form>

        <!-- Кнопка избранного из старого HTML -->
        <div class="favorites-wrapper">
            <div class="favorite-wrapper" id="header-favorites-btn" style="display: none;" onclick="window.location.href='/favorites'">
              <span class="particle particle-1">✦</span>
              <span class="particle particle-2">✦</span>
              <span class="particle particle-3">✦</span>
              <span class="particle particle-4">✦</span>
              <span class="particle particle-5">✦</span>
                <span class="particle particle-6">✦</span>
              <span class="particle particle-7">✦</span>
              <span class="heart-icon">❤</span>
              <span class="favorites-counter" id="favorites-count">0</span>
            </div>
        </div>

        <!-- Кнопки входа/регистрации из старого HTML с визуалом нового -->
        <div class="auth-buttons">
            <button id="loginButton" class="btn-login" onclick="showWindow()">Вход</button>
            <button id="registerButton" class="btn-register" onclick="showWindow1()">Регистрация</button>
            <div id="userInfo" style="display: none;">
                <div class="Коробка">
                    <img id="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Avatar">
                    <span id="welcomeUser"></span>
                </div>
                <button class="btn-logout" onclick="logout()">Выход</button>
            </div>
        </div>
    </div>
    <div class="clouds"></div>
</nav>

<!-- Окна входа/регистрации из старого HTML -->
<div id="overlay" style="display: none;"></div>

<div id="content_window" class="popup-window">
    <form id="loginForm" method="POST" action="/login">
        <h1>Вход</h1>
        <span class="btnX" onclick="hideWindow()">×</span>
        <div class="form-group">
            <label for="username">Логин</label>
            <input type="text" class="form-control" id="username" name="username" placeholder="Введите логин" required>
        </div>
        <div class="form-group">
            <label for="password">Пароль</label>
            <input type="password" class="form-control" id="password" name="password" placeholder="Введите пароль" required>
        </div>
        <button type="submit" class="btnA">Войти</button>
    </form>
</div>

<div id="content_window2" class="popup-window">
    <form id="regForm" method="POST" action="/register">
        <h1>Регистрация</h1>
        <span class="btnX" onclick="hideWindow1()">×</span>
        <div class="form-group">
            <label for="username1">Логин</label>
            <input type="text" id="username1" name="username" class="form-control" placeholder="Введите логин" required>
        </div>
        <div class="form-group">
            <label for="password1">Пароль</label>
            <input type="password" id="password1" name="password" class="form-control" placeholder="Введите пароль" required>
        </div>
        <div class="form-group">
            <label for="password2">Подтвердите пароль</label>
            <input type="password" id="password2" name="confirm_password" class="form-control" placeholder="Подтвердите пароль" required>
        </div>
        <div class="form-group">
            <label for="secret_key">Секретный ключ</label>
            <input type="password" id="secret_key" name="secret_key" class="form-control" placeholder="Введите секретный ключ" required>
        </div>
        <button type="submit" class="btnB">Зарегистрироваться</button>
    </form>
</div>

    <!-- Задний фон -->
    <div class="image-container">
        <img src="{{ url_for('static', filename='Фотки зданий/РесторанФон.jpg') }}" class="img-top-center" alt="РесторанФон.jpg">
    </div>
    <div class="box">
        <div class="container">
            <!-- Левая часть: картинка -->
            <div class="image-section">
                <div class="image-flip-container">
                    <!-- Передняя сторона (картинка) -->
                    <div class="image-front" >
                        <img src="{{ url_for('static', filename='Фотки зданий/Барашки.png') }}" alt="Ресторан Барашки">
                        <!-- Кнопка на карточке заведения -->
                        <button class="favorite-btn js-favorite-btn"
                                data-item-id="lambs"
                                data-item='{"id":"lambs","name":"Ресторан Lambs"}'
                                onclick="toggleFavorite('lambs', this)">
                          ❤
                        </button>
                        <!-- Кнопка развернуть в правом нижнем углу -->
                        <button class="expand-btn" onclick="expandImage(this)">↗</button>
                        <!-- Кнопка показать карту по центру снизу -->
                        <button class="map-btn" onclick="flipCard()">Показать карту</button>
                        <!-- График работы в левом верхнем углу -->
                        <div class="schedule-dropdown">
                            <button class="schedule-btn">График работы ▼</button>
                            <div class="schedule-content" id="schedule-content">
                                Пн-Пт: 10:00 - 22:00<br>
                                Сб-Вс: 11:00 - 23:00
                            </div>
                        </div>
                        <!-- Кнопка меню по центру снизу -->
                        <button class="menu-btn" onclick="openMenuModal()">Меню</button>
                    </div>

                    <!-- Задняя сторона (карта) -->
                    <div class="image-back">
                        <div class="map-container" id="map-container">
                            <h3>ул. Ломоносова, 22/2, Великий Новгород</h3>
                            <div id="yandex-map" style="width: 500px; height: 400px;">
                                <script type="text/javascript" charset="utf-8" async
                                        src="https://api-maps.yandex.ru/services/constructor/1.0/js/?um=constructor%3A5a6e03b338adf645bf44cf4d3ff45a9dae7e8cf7644abacde6f0b25ba231517d&amp;width=500&amp;height=400&amp;lang=ru_RU&amp;scroll=true">
                                </script>
                            </div>
                        </div>

                        <!-- Кнопка вернуться к изображению по центру снизу -->
                        <button class="back-btn" onclick="flipCard()">Показать изображение</button>
                    </div>
                </div>
            </div>

            <!-- Правая часть: описание -->
            <div class="details-section">
                <h1>Барашки</h1>
                <p>Ресторан «Барашки» предлагает своим гостям блюда грузинской кухни, приготовленные по традиционным рецептам.</p>
                <svg style="width: 18px; height: 18px; font-size: 17px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
                <p>+7 (8162) 55-53-22</p>
            </div>
        </div>

        <!-- Блок отзывов -->
        <div class="reviews">
            <h2>Отзывы</h2>
            <p>Общая оценка: <strong id="overall-rating">0.0</strong> (на основе <span id="total-reviews">0</span> отзывов)</p>
            <div class="rating-bars">
                <div class="rating-bar">
                    <span>5 звёзд</span>
                    <div class="bar" style="margin-left: 10px"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>4 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>3 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>2 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>1 звезда</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
            </div>

            <!-- Фильтр отзывов -->
            <div class="review-filter">
                <label>Фильтр по оценкам:</label>
                <div class="filter-controls">
                    <div class="stars" id="filter-stars">
                        <span class="star" data-value="1">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="2">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="3">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="4">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="5">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                    </div>
                    <div class="reaction-filters">
                        <span class="filter-btn" data-type="likes" title="Показать отзывы с лайками">
                            <img src="{{ url_for('static', filename='Фотки зданий/Лайк.png') }}" alt="Лайки">
                        </span>
                        <span class="filter-btn" data-type="dislikes" title="Показать отзывы с дизлайками">
                            <img src="{{ url_for('static', filename='Фотки зданий/Дизлайк.png') }}" alt="Дизлайки">
                        </span>
                    </div>
                </div>
            </div>

            <!-- Контейнер для отзывов -->
            <div class="review-container">
                <button class="scroll-button left" onclick="scrollReviews('left')">◄</button>
                <div class="review-list" id="review-list">
                    <!-- Отзывы будут добавляться сюда -->
                </div>
                <button class="scroll-button right" onclick="scrollReviews('right')">►</button>
            </div>

            <!-- Кнопка "Оставить отзыв" -->
            <button class="review-container-button" onclick="openReviewModal()">Оставить отзыв</button>
        </div>

        <!-- Модальное окно для меню -->
        <div class="modal" id="menu-modal">
            <div class="modal-content">
                <h2>Меню</h2>
                <p>Здесь будет содержимое меню.</p>
                <button onclick="closeMenuModal()">Закрыть</button>
            </div>
        </div>

        <!-- Модальное окно для отзыва -->
        <div class="modal" id="review-modal">
            <div class="modal-content">
                <span class="close" onclick="closeReviewModal()">&times;</span>
                <h2>Оставить отзыв</h2>
                <form id="review-form">
                    <label class="review-form-name" for="name">Имя:</label>
                    <input type="text" id="name" required><br><br>
                    <label>Оценка: <span id="rating-error" style="color: red; display: none; font-size: 11px">*Обязательное поле</span></label>
                    <div class="stars" id="review-stars">
                        <span class="star" data-value="1">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="2">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="3">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="4">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="5">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                    </div><br>
                    <label for="comment">Комментарий:</label><br>
                    <textarea id="comment" rows="4"></textarea><br><br>
                    <button class="review-form-button" type="submit">Отправить</button>
                </form>
            </div>
        </div>

        <!-- Модальное окно для развёрнутого отзыва -->
        <div class="modal" id="full-review-modal">
            <div class="modal-content">
                <span class="close" onclick="closeFullReviewModal()">&times;</span>
                <h2>Полный отзыв</h2>

                <div class="review-header">
                    <img class="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Аватар">
                    <div class="name-rating-modal">
                        <div class="review-name"></div>
                        <div class="review-rating"></div>
                    </div>
                </div>

                <div class="review-comment"></div>

                <div class="review-actions">
                    <button class="like-btn" onclick="rateReview(true, '${review.id || Date.now()}')">
                        <img src="{{ url_for('static', filename='Фотки зданий/Лайк.png') }}" alt="Лайк">
                        <span class="like-count">0</span>
                    </button>
                    <button class="dislike-btn" onclick="rateReview(false, '${review.id || Date.now()}')">
                        <img src="{{ url_for('static', filename='Фотки зданий/Дизлайк.png') }}" alt="Дизлайк">
                        <span class="dislike-count">0</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно для редактирования отзыва -->
<div class="modal" id="edit-review-modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditReviewModal()">&times;</span>
        <h2>Редактировать отзыв</h2>
        <form id="edit-review-form">
            <label>Оценка:</label>
            <div class="stars">
                <span class="star" data-value="1" onclick="setRating(this, 1)">
                    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </span>
                <span class="star" data-value="2" onclick="setRating(this, 2)">
                    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </span>
                <span class="star" data-value="3" onclick="setRating(this, 3)">
                    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </span>
                <span class="star" data-value="4" onclick="setRating(this, 4)">
                    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </span>
                <span class="star" data-value="5" onclick="setRating(this, 5)">
                    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </span>
            </div>
            <label for="edit-comment">Комментарий:</label>
            <textarea id="edit-comment" rows="4"></textarea>
            <button type="submit" class="submit-btn">Сохранить изменения</button>
        </form>
    </div>
</div>

    <!-- Городской силуэт перед футером -->
    <div class="skyscrapers"></div>

    <!-- Футер -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section about">
                <img src="{{ url_for('static', filename='Фотки зданий/лого.png') }}" style="width: 120px;" alt="Логотип">
                <p>Городской гид - ваш путеводитель по лучшим местам Великого Новгорода</p>
                <div class="socials">
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/TG.png') }}" alt="Telegram"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/YT.png') }}" style="margin-bottom: 0; margin-top: 8px" alt="YouTube"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/vk.png') }}" alt="VK"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/OK.png') }}" alt="OK"></a>
                </div>
            </div>

            <div class="footer-section links">
                <h3>Навигация</h3>
                <ul>
                    <li><a href="#">Главная</a></li>
                    <li><a href="#">О проекте</a></li>
                    <li><a href="#">Контакты</a></li>
                    <li><a href="#">Помощь</a></li>
                </ul>
            </div>

            <div class="footer-section contact">
                <h3>Контакты</h3>
                <p><i class="phone-icon"></i> +7 (123) 456-78-90</p>
                <p><i class="email-icon"></i> info@gorodskoygid.ru</p>
                <p><i class="location-icon"></i> Великий Новгород</p>
            </div>
        </div>

        <div class="footer-bottom">
            &copy; 2025 Городской Гид | Все права защищены
        </div>
    </footer>
    <script>
        // Константы
// Константы
const PATHS = {
    starActive: "/static/Фотки зданий/baka.png",
    starInactive: "/static/Фотки зданий/star.png",
    avatar: "/static/Фотки зданий/avatar.png",
    like: "/static/Фотки зданий/Лайк.png",
    dislike: "/static/Фотки зданий/Дизлайк.png"
};

// Массив для хранения отзывов
    let reviews = [];

// Глобальные переменные
const currentRestaurantId = 'lambs';
let selectedRating = 0;
let lastReviewTime = localStorage.getItem('lastReviewTime') || 0;

// Генерируем токен СРАЗУ при загрузке скрипта
let userToken = localStorage.getItem('userToken') || generateUserToken();

let currentFilters = {
    rating: 0,
    reaction: 'none'
};

document.addEventListener('DOMContentLoaded', function() {
    updateFavoritesCount(); // Проверка избранного при загрузке
    initStats(); // Загрузка статистики и отзывов Вместо updateOverallRating()
    initFilters(); // Инициализация фильтров - ДОБАВЬТЕ ЭТУ СТРОЧКУ!
    loadReviews(); // Загрузка отзывов
    setInterval(saveRatingsToStorage, 30000); // Периодическое сохранение (каждые 30 секунд)

    document.getElementById('full-review-modal').style.display = 'none';

    // Обработчик скролла
    const reviewList = document.getElementById('review-list');
    if (reviewList) {
        reviewList.addEventListener('scroll', updateScrollButtons);
    }

    // Генерируем токен
    userToken = generateUserToken();
    console.log('User token:', userToken);


    // Обработчики для кнопок в карточках
    document.querySelectorAll('.js-favorite-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const itemId = this.dataset.itemId;
      const itemData = JSON.parse(this.dataset.item);
      toggleFavorite(itemId, itemData);
    });
    });

    // Синхронизация между вкладками
    window.addEventListener('storage', function(event) {
    if (event.key === 'favorites') {
      updateFavoritesCount();
    }
    });

    // Инициализация кнопки
    const headerFavBtn = document.getElementById('header-favorites-btn');
    const particles = headerFavBtn.querySelectorAll('.particle');

    // Анимация частиц
    headerFavBtn.addEventListener('mouseenter', function() {
    this.classList.add('active');
    });

    headerFavBtn.addEventListener('mouseleave', function() {
    this.classList.remove('active');
    });

    // Обработчик для кнопки закрытия
    const closeBtn = document.querySelector('#review-modal .close');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeReviewModal);
    }

    // УБЕРИТЕ все другие обработчики для review-form и оставьте только этот:
    const reviewForm = document.getElementById('review-form');
    if (reviewForm) {
        // Удаляем все предыдущие обработчики
        reviewForm.onsubmit = null;
        reviewForm.addEventListener('submit', function(e) {
            submitReview(e);
        });
    }

    // Обработчик клика вне модального окна
    const modal = document.getElementById('review-modal');
    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                closeReviewModal();
            }
        });
    }

    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));

            // Обновляем отображение звезд
            stars.forEach((s, index) => {
                const starValue = parseInt(s.getAttribute('data-value'));
                const starImage = starValue <= selectedRating ? PATHS.starActive : PATHS.starInactive;
                s.innerHTML = `<img src="${starImage}" alt="★">`;
            });

            document.getElementById('rating-error').style.display = 'none';
        });
    });


    setTimeout(() => {updateScrollButtons();}, 500);
    setTimeout(updateScrollButtons, 1000); // Проверяем кнопки после полной загрузки страницы

    setTimeout(() => {
        updateScrollButtons();
        // Дополнительная проверка через секунду
        setTimeout(updateScrollButtons, 1000);
    }, 500);

    // Остальная инициализация...
});

// Новая функция для инициализации кнопок скролла
function initScrollButtons() {
    const reviewList = document.getElementById('review-list');
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!reviewList || !leftButton || !rightButton) {
        console.log('Scroll elements not found during init');
        return;
    }

    // Принудительно показываем кнопки для проверки
    leftButton.style.display = 'block';
    rightButton.style.display = 'block';

    // Проверяем контент после небольшой задержки
    setTimeout(() => {
        const hasContent = reviewList.children.length > 0;
        const canScroll = reviewList.scrollWidth > reviewList.clientWidth;

        console.log('Init scroll check:', {
            children: reviewList.children.length,
            scrollWidth: reviewList.scrollWidth,
            clientWidth: reviewList.clientWidth,
            canScroll: canScroll
        });

        if (hasContent && canScroll) {
            leftButton.style.display = 'block';
            rightButton.style.display = 'block';
            updateScrollButtons();
        } else {
            leftButton.style.display = 'none';
            rightButton.style.display = 'none';
        }
    }, 100);
}

// Генерация уникального токена пользователя
// Улучшенная генерация токена
function generateUserToken() {
    let token = localStorage.getItem('userToken');

    if (!token) {
        const deviceId = getDeviceFingerprint();
        token = `token-${deviceId}-${Math.random().toString(36).substr(2, 8)}-${Date.now().toString(36)}`;
        localStorage.setItem('userToken', token);
    }

    return token;
}

function validateReviewForm() {
    const name = document.getElementById('name').value.trim();
    const rating = selectedRating;

    if (!name) {
        document.getElementById('name').style.borderColor = '#ff4444';
        return false;
    }

    if (rating === 0) {
        document.getElementById('rating-error').style.display = 'inline';
        return false;
    }

    return true;
}

async function submitReview(e) {
    if (e) e.preventDefault();

    const name = document.getElementById('name').value.trim();
    const comment = document.getElementById('comment').value.trim();

    if (!validateReviewForm()) {
        return false;
    }

    if (selectedRating === 0) {
        showNotification('Пожалуйста, поставьте оценку', 'error');
        document.getElementById('rating-error').style.display = 'inline';
        return false;
    }

    if (!name) {
        showNotification('Пожалуйста, укажите имя', 'error');
        return false;
    }

    try {
        // Сохраняем fingerprint устройства
        const deviceFingerprint = getDeviceFingerprint();
        console.log('Submitting review with device fingerprint:', deviceFingerprint);

        const response = await fetch('/api/reviews', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                restaurant_id: currentRestaurantId,
                username: name,
                rating: selectedRating,
                comment: comment,
                user_token: userToken,
                device_fingerprint: deviceFingerprint
            })
        });

        const data = await response.json();

        if (response.ok) {
            showNotification('Отзыв успешно добавлен!', 'success');
            closeReviewModal();

            // ДОБАВЛЯЕМ user_token к данным отзыва перед отображением
            data.user_token = userToken;
            data.device_fingerprint = deviceFingerprint;

            // Плавно обновляем только отзывы
            await loadReviews();
            await initStats();

            // Плавная прокрутка к новому отзыву
            setTimeout(() => {
                const newReview = document.querySelector('.review-card:first-child');
                if (newReview) {
                    newReview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 300);
        }

    } catch (error) {
        console.error('Error:', error);
        showNotification(error.message, 'error');
        return false;
    }
}

function showLoadingIndicator() {
    let loader = document.getElementById('submit-loader');
    if (!loader) {
        loader = document.createElement('div');
        loader.id = 'submit-loader';
        loader.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
        `;
        loader.innerHTML = 'Отправка отзыва...';
        document.body.appendChild(loader);
    }
    loader.style.display = 'block';
}

function hideLoadingIndicator() {
    const loader = document.getElementById('submit-loader');
    if (loader) {
        loader.style.display = 'none';
    }
}

function addReviewToUIImmediately(review) {
    const reviewList = document.getElementById('review-list');

    // Убираем сообщение "Нет отзывов"
    const noReviewsMsg = reviewList.querySelector('.no-reviews');
    if (noReviewsMsg) {
        noReviewsMsg.remove();
    }

    // ГАРАНТИРУЕМ что у нового отзыва есть user_token и device_fingerprint
    if (!review.user_token) {
        review.user_token = userToken;
        console.log('Added user token to new review:', review.user_token);
    }

    if (!review.device_fingerprint) {
        review.device_fingerprint = getDeviceFingerprint();
        console.log('Added device fingerprint to new review:', review.device_fingerprint);
    }

    // Создаем элемент отзыва
    const reviewElement = createReviewElement(review);

    // Добавляем в начало списка с анимацией
    if (reviewList.firstChild) {
        reviewList.insertBefore(reviewElement, reviewList.firstChild);
    } else {
        reviewList.appendChild(reviewElement);
    }

    // Анимация появления
    reviewElement.style.opacity = '0';
    reviewElement.style.transform = 'translateY(-20px)';

    setTimeout(() => {
        reviewElement.style.transition = 'all 0.3s ease';
        reviewElement.style.opacity = '1';
        reviewElement.style.transform = 'translateY(0)';
    }, 10);

    // Обновляем скролл-кнопки
    setTimeout(updateScrollButtons, 100);

    // Добавляем в глобальный массив отзывов
    reviews.unshift(review);
}

// Функция для отображения отзывов
function displayReviews(reviewsData) {
    const reviewList = document.getElementById('review-list');
    if (!reviewList) return;

    reviewList.innerHTML = '';
    reviews = reviewsData || [];

    if (!reviewsData || reviewsData.length === 0) {
        reviewList.innerHTML = '<div class="no-reviews">Пока нет отзывов. Будьте первым!</div>';
        updateScrollButtons();
        return;
    }

    reviewsData.forEach(review => {
        const reviewElement = createReviewElement(review);
        reviewList.appendChild(reviewElement);
    });

    // Ждем отрисовки DOM
    setTimeout(updateScrollButtons, 100);
}

// Обновление статистики
function updateRatingStats(stats) {
    document.getElementById('overall-rating').textContent = stats.average_rating.toFixed(1);
    document.getElementById('total-reviews').textContent = stats.total_reviews;

    // Обновляем шкалы рейтинга
    for (let i = 1; i <= 5; i++) {
        const count = stats.ratings[i] || 0;
        const percentage = stats.total_reviews > 0 ? (count / stats.total_reviews) * 100 : 0;
        const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
        const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);

        if (bar) bar.style.width = `${percentage}%`;
        if (countSpan) countSpan.textContent = count;
    }
}

// Обновленный UI для отзывов с возможностью редактирования
function updateReviewsUI(reviews) {
    const reviewList = document.getElementById('review-list');
    reviewList.innerHTML = '';

    if (!reviews || reviews.length === 0) {
        reviewList.innerHTML = '<div class="no-reviews">Пока нет отзывов. Будьте первым!</div>';
        return;
    }

    reviews.forEach(review => {
        const canEdit = checkEditPermission(review);
        const reviewElement = createReviewElement(review, canEdit);
        reviewList.appendChild(reviewElement);
    });

    updateReviewVisibility();
}

// Функция для создания элемента отзыва
function createReviewElement(review) {
    const reviewElement = document.createElement('div');
    reviewElement.className = 'review-card';
    reviewElement.dataset.reviewId = review.id || Date.now();
    reviewElement.dataset.likes = review.likes || 0;
    reviewElement.dataset.dislikes = review.dislikes || 0;

    // Экранируем кавычки для безопасности
    const safeComment = review.comment ? review.comment.replace(/'/g, "&#39;").replace(/"/g, "&quot;") : '';
    const safeUsername = review.username ? review.username.replace(/'/g, "&#39;").replace(/"/g, "&quot;") : '';

    // Форматируем дату
    const reviewDate = review.created_at ?
        formatDate(review.created_at) :
        'Только что';

    // Создаем HTML для звезд рейтинга
    let starsHTML = '';
    for (let i = 0; i < 5; i++) {
        if (i < review.rating) {
            starsHTML += `<img src="${PATHS.starActive}" alt="★" style="width:20px;height:20px;">`;
        } else {
            starsHTML += `<img src="${PATHS.starInactive}" alt="★" style="width:20px;height:20px;">`;
        }
    }

    // УБИРАЕМ кнопки лайков/дизлайков из карточки
    reviewElement.innerHTML = `
        <div class="review-header">
            <div class="date-avatar">
                <img class="avatar" src="${PATHS.avatar}" alt="Аватар">
                <div class="review-date-small">${reviewDate}</div>
            </div>
            <div class="name-rating">
                <div class="name">${safeUsername}</div>
                <div class="review-rating">
                    ${starsHTML}
                </div>
            </div>
        </div>
        <div class="comment-container">
            <div class="comment-text">${review.comment || ''}</div>
            ${review.comment ? '<div class="comment-blur"></div>' : ''}
        </div>
        ${review.comment ? `
            <div class="review-actions-bottom">
                <button class="expand-text-link" onclick="openFullReviewModal(${review.id || Date.now()})">
                    Развернуть
                </button>
            </div>
        ` : ''}
    `;

    // Добавляем кнопки редактирования если есть права
    const canEdit = checkEditPermission(review);
    if (canEdit) {
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'review-actions';
        actionsDiv.innerHTML = `
            <button class="edit-btn" onclick="openEditReviewModal(${review.id || Date.now()}, ${review.rating}, '${safeComment}')">
                Редактировать
            </button>
            <button class="delete-btn" onclick="deleteReview(${review.id || Date.now()})">
                Удалить
            </button>
        `;
        reviewElement.appendChild(actionsDiv);
    }

    return reviewElement;
}

// Проверка прав на редактирование с улучшенной безопасностью
function checkEditPermission(review) {
    console.log('Checking edit permission for review:', review);
    console.log('User token:', userToken);
    console.log('Review user token:', review.user_token);

    // Проверяем токен пользователя
    if (review.user_token !== userToken) {
        console.log('Token mismatch!');
        console.log('Expected:', userToken);
        console.log('Got:', review.user_token);
        return false;
    }

    // Проверяем время (3 часа)
    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    console.log('Created at:', createdAt);
    console.log('Now:', now);
    console.log('Hours difference:', hoursDiff);

    if (hoursDiff > 3) {
        console.log('Edit time expired');
        return false;
    }

    // Дополнительная проверка устройства
    const sameDevice = isSameDevice(review);
    console.log('Same device:', sameDevice);

    if (!sameDevice) {
        console.log('Different device detected');
        // Для новых отзывов даем 5 минут grace period
        const minutesDiff = (now - createdAt) / (1000 * 60);
        if (minutesDiff > 5) {
            return false;
        }
    }

    console.log('Edit permission GRANTED');
    return true;
}

// Функция проверки того же устройства
function isSameDevice(review) {
    // Получаем fingerprint текущего устройства
    const currentFingerprint = getDeviceFingerprint();

    // Если в отзыве есть сохраненный fingerprint, сравниваем
    if (review.device_fingerprint) {
        return review.device_fingerprint === currentFingerprint;
    }

    // Если fingerprint нет в отзыве, считаем что это новое устройство
    // и разрешаем редактирование только если отзыв создан менее 5 минут назад
    const createdAt = new Date(review.created_at);
    const now = new Date();
    const minutesDiff = (now - createdAt) / (1000 * 60);

    return minutesDiff < 5; // Разрешаем с нового устройства только первые 5 минут
}

// Форматирование даты
function formatDate(dateString) {
    if (!dateString) return '<div>Только что</div><div></div>';

    try {
        const date = new Date(dateString);
        const formattedDate = date.toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'numeric',
            year: 'numeric'
        });
        const formattedTime = date.toLocaleTimeString('ru-RU', {
            hour: '2-digit',
            minute: '2-digit'
        });

        return `<div>${formattedDate}</div><div>${formattedTime}</div>`;
    } catch (e) {
        return '<div>Только что</div><div></div>';
    }
}

// Модальное окно для редактирования
function openEditModal(reviewId, currentRating, currentComment) {
    const modal = document.getElementById('edit-modal');
    modal.dataset.reviewId = reviewId;

    // Установка текущего рейтинга
    const stars = modal.querySelectorAll('.star');
    stars.forEach((star, index) => {
        star.innerHTML = `<img src="${index < currentRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
    });

    // Установка комментария
    modal.querySelector('#edit-comment').value = currentComment || '';

    // Показываем модальное окно
    modal.style.display = 'flex';
}

// Функция для обновления отзыва
async function updateReview() {
    const modal = document.getElementById('edit-modal');
    const reviewId = modal.dataset.reviewId;
    const comment = modal.querySelector('#edit-comment').value.trim();
    const rating = parseInt(modal.querySelector('.rating').dataset.rating);

    try {
        const response = await fetch(`/api/reviews/${reviewId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                rating: rating,
                comment: comment,
                user_token: userToken
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка при обновлении отзыва');
        }

        showNotification('Отзыв успешно обновлен!');
        closeEditModal();
        loadReviews();
    } catch (error) {
        console.error('Error:', error);
        showNotification(error.message, 'error');
    }
}

// Функция для удаления отзыва
async function deleteReview(reviewId) {
    if (!confirm('Вы уверены, что хотите удалить этот отзыв?')) return;

    try {
        const response = await fetch(`/api/reviews/${reviewId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                user_token: userToken
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка при удалении отзыва');
        }

        showNotification('Отзыв успешно удален!');
        loadReviews();
    } catch (error) {
        console.error('Error:', error);
        showNotification(error.message, 'error');
    }
}

// Закрытие модального окна редактирования
function closeEditModal() {
    document.getElementById('edit-modal').style.display = 'none';
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    loadReviews();
    updateOverallRating();

    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));
            stars.forEach((s, index) => {
                s.innerHTML = `<img src="${index < selectedRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
            });
        });
    });
});

// Улучшенная функция генерации токена
function generateEnhancedUserToken() {
    // Собираем информацию о браузере (анонимно)
    const browserInfo = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${screen.width}x${screen.height}`
    };

    // Создаем хэш на основе информации
    const browserHash = btoa(JSON.stringify(browserInfo)).substr(0, 12);

    const token = `token-${browserHash}-${Math.random().toString(36).substr(2, 6)}-${Date.now().toString(36)}`;

    localStorage.setItem('userToken', token);
    return token;
}

// Улучшенная функция получения отпечатка устройства
function getDeviceFingerprint() {
    const components = [
        navigator.userAgent,
        navigator.language,
        Intl.DateTimeFormat().resolvedOptions().timeZone,
        `${screen.width}x${screen.height}`,
        navigator.platform,
        navigator.hardwareConcurrency || 'unknown',
        navigator.deviceMemory || 'unknown',
        new Date().getTimezoneOffset()
    ];

    // Более стабильный хэш
    let hash = 0;
    const str = components.join('|');

    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }

    // Добавляем префикс для идентификации
    return `fp-${Math.abs(hash).toString(36).substr(0, 10)}`;
}
















// Инициализация фильтров
function initFilters() {
    // Обработчики для звезд
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.addEventListener('click', function() {
            const value = parseInt(this.getAttribute('data-value'));

            // Если кликаем на уже выбранную звезду - сбрасываем
            if (currentFilters.rating === value) {
                currentFilters.rating = 0;
                resetStarFilter();
            } else {
                currentFilters.rating = value;
                highlightStars(value);
            }

            applyFilters();
        });
    });

    // Обработчики для кнопок реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const filterType = this.getAttribute('data-type');

            // Если кликаем на уже активную кнопку - сбрасываем
            if (currentFilters.reaction === filterType) {
                currentFilters.reaction = 'none';
                resetReactionFilter();
            } else {
                currentFilters.reaction = filterType;
                highlightReactionButton(filterType);
            }

            applyFilters();
        });
    });

    resetScroll();
}

function resetAllFilters() {
    currentFilters = {
        rating: 0,
        reaction: 'none'
    };

    // Сбрасываем звезды
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });

    // Сбрасываем кнопки реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
    });

    // Применяем фильтры (покажет все отзывы)
    applyFilters();

    // Сбрасываем скролл
    resetScroll();
}

function updateFilterButtons() {
    // Обновляем кнопки реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === currentFilters.reaction) {
            btn.classList.add('active');
        }
    });

    // Обновляем звезды фильтра
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= currentFilters.rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★">`;
    });
}

// Функция применения фильтров
function applyFilters() {
    const reviewList = document.getElementById('review-list');
    const reviewCards = reviewList.querySelectorAll('.review-card');
    let hasMatches = false;

    const oldMsg = document.getElementById('no-reviews-message');
    if (oldMsg) oldMsg.remove();

    reviewCards.forEach(card => {
        const ratingImages = card.querySelectorAll('.review-rating img[src*="baka.png"]');
        const cardRating = ratingImages.length;
        const likes = parseInt(card.dataset.likes || 0);
        const dislikes = parseInt(card.dataset.dislikes || 0);

        const matchesRating = currentFilters.rating === 0 || cardRating === currentFilters.rating;
        const matchesReaction = checkReactionMatch(likes, dislikes);

        if (matchesRating && matchesReaction) {
            card.style.display = 'flex';
            hasMatches = true;
        } else {
            card.style.display = 'none';
        }
    });

    if (currentFilters.reaction !== 'none' && hasMatches) {
        sortReviewsByReaction();
    }

    if (!hasMatches) {
        showNoReviewsMessage();
    }

    // Обновляем скролл после фильтрации
    setTimeout(updateScrollButtons, 150);
}

function resetScroll() {
    const reviewList = document.getElementById('review-list');
    if (reviewList) {
        reviewList.scrollLeft = 0;
        setTimeout(updateScrollButtons, 150);
    }
}

// Проверка соответствия фильтру реакций
function checkReactionMatch(likes, dislikes) {
    switch (currentFilters.reaction) {
        case 'likes':
            return likes > 0;
        case 'dislikes':
            return dislikes > 0;
        case 'none':
        default:
            return true;
    }
}

// Подсветка звезд фильтра
function highlightStars(rating) {
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★">`;
    });
}

// Подсветка кнопки реакции
function highlightReactionButton(filterType) {
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === filterType) {
            btn.classList.add('active');
        }
    });
}

// Сброс фильтра звезд
function resetStarFilter() {
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });
}

// Сброс фильтра реакций
function resetReactionFilter() {
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === 'none') {
            btn.classList.add('active');
        }
    });
}

// Функция сортировки отзывов
function sortReviews(reviewsArray) {
    if (currentFilter.reaction === 'likes') {
        reviewsArray.sort((a, b) => b.likes - a.likes);
    } else if (currentFilter.reaction === 'dislikes') {
        reviewsArray.sort((a, b) => b.dislikes - a.dislikes);
    }
}

// Сообщение об отсутствии отзывов
function showNoReviewsMessage() {
    const reviewList = document.getElementById('review-list');
    const msg = document.createElement('div');
    msg.id = 'no-reviews-message';

    let messageText = 'Отзывов нет';
    if (currentFilters.rating !== 0) {
        messageText += ` с ${currentFilters.rating} звездами`;
    }
    if (currentFilters.reaction !== 'none') {
        messageText += currentFilters.rating !== 0 ? ' и' : ' с';
        messageText += currentFilters.reaction === 'likes' ? ' лайками' : ' дизлайками';
    }

    msg.textContent = messageText + '!';
    msg.style.textAlign = 'center';
    msg.style.padding = '20px';
    msg.style.color = '#666';
    msg.style.width = '100%';

    // Очищаем и добавляем сообщение
    reviewList.innerHTML = '';
    reviewList.appendChild(msg);

    // Обновляем кнопки скролла
    updateScrollButtons();
}

// Функция сброса противоположного фильтра
function resetOppositeFilter() {
    // При изменении звезд сбрасываем реакции
    if (currentFilter.rating !== 0 && currentFilter.reaction !== 'none') {
        currentFilter.reaction = 'none';
        const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
        filterButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-type') === 'none') {
                btn.classList.add('active');
            }
        });
    }

    // При изменении реакций сбрасываем звезды
    if (currentFilter.reaction !== 'none' && currentFilter.rating !== 0) {
        currentFilter.rating = 0;
        const filterStars = document.querySelectorAll('#filter-stars .star');
        filterStars.forEach(star => {
            star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
        });
    }
}

// Сортировка по реакциям
function sortReviewsByReaction() {
    const reviewList = document.getElementById('review-list');
    const visibleReviews = Array.from(reviewList.querySelectorAll('.review-card'))
        .filter(card => card.style.display !== 'none');

    visibleReviews.sort((a, b) => {
        const aLikes = parseInt(a.dataset.likes || 0);
        const bLikes = parseInt(b.dataset.likes || 0);
        const aDislikes = parseInt(a.dataset.dislikes || 0);
        const bDislikes = parseInt(b.dataset.dislikes || 0);

        if (currentFilters.reaction === 'likes') {
            return bLikes - aLikes;
        } else if (currentFilters.reaction === 'dislikes') {
            return bDislikes - aDislikes;
        }
        return 0;
    });

    // Переставляем отзывы в правильном порядке
    visibleReviews.forEach(review => {
        reviewList.appendChild(review);
    });
}



// ===== КОНФИГУРАЦИЯ =====
const STORAGE_KEY = 'restaurant_reviews_ratings';

// ===== ОСНОВНЫЕ ФУНКЦИИ =====

// Функция для сохранения оценок в LocalStorage
function saveRatingsToStorage() {
    const ratingsData = {
        version: '2.0', // Обновили версию
        timestamp: new Date().toISOString(),
        ratings: reviews.reduce((acc, review) => {
            if (review.id) {
                acc[review.id] = {
                    likes: review.likes || 0,
                    dislikes: review.dislikes || 0,
                    user_ratings: review.user_ratings || {} // Храним оценки пользователей
                };
            }
            return acc;
        }, {})
    };

    localStorage.setItem(STORAGE_KEY, JSON.stringify(ratingsData));
    console.log('Ratings saved to localStorage');
}

// Функция для загрузки оценок из LocalStorage
function loadRatingsFromStorage() {
    try {
        const storedData = localStorage.getItem(STORAGE_KEY);
        if (!storedData) return {};

        const data = JSON.parse(storedData);

        // Проверяем версию
        if (data.version === '2.0') {
            return data.ratings || {};
        }
    } catch (error) {
        console.error('Error loading ratings from storage:', error);
    }
    return {};
}

// Функция для применения сохраненных оценок
function applyStoredRatings() {
    const storedRatings = loadRatingsFromStorage();

    reviews.forEach(review => {
        if (review.id && storedRatings[review.id]) {
            const stored = storedRatings[review.id];
            review.likes = stored.likes;
            review.dislikes = stored.dislikes;
            review.user_ratings = stored.user_ratings || {};
        }
    });

    console.log('Stored ratings applied');
}

// ===== ОБНОВЛЕННАЯ ФУНКЦИЯ rateReview =====
async function rateReview(isLike, reviewId) {
    if (!reviewId) return;

    try {
        const reviewIndex = reviews.findIndex(r => r.id == reviewId);
        if (reviewIndex === -1) return;

        const review = reviews[reviewIndex];

        // Сохраняем позицию скролла
        const reviewList = document.getElementById('review-list');
        const scrollPosition = reviewList.scrollLeft;

        // Инициализируем user_ratings если нет
        if (!review.user_ratings) {
            review.user_ratings = {};
        }

        const userPreviousRating = review.user_ratings[userToken];

        // Подсветка кнопки в модальном окне с вашими стилями
        const modal = document.getElementById('full-review-modal');
        if (modal && modal.dataset.reviewId == reviewId) {
            const buttonClass = isLike ? 'like-btn' : 'dislike-btn';
            const button = modal.querySelector(`.${buttonClass}`);
            if (button) {
                button.classList.add('highlight');
                setTimeout(() => button.classList.remove('highlight'), 500);
            }
        }

        // Логика оценки
        if (userPreviousRating === (isLike ? 'like' : 'dislike')) {
            removeRating(review, isLike);
            delete review.user_ratings[userToken];
            showNotification('Оценка отменена!');
        } else if (userPreviousRating) {
            removeRating(review, !isLike);
            addRating(review, isLike);
            review.user_ratings[userToken] = isLike ? 'like' : 'dislike';
            showNotification(isLike ? 'Лайк поставлен!' : 'Дизлайк поставлен!');
        } else {
            addRating(review, isLike);
            review.user_ratings[userToken] = isLike ? 'like' : 'dislike';
            showNotification(isLike ? 'Лайк поставлен!' : 'Дизлайк поставлен!');
        }

        // Обновляем UI
        updateRatingUI(reviewId, review.likes, review.dislikes);
        saveRatingsToStorage();

        // Восстанавливаем позицию скролла
        setTimeout(() => {
            reviewList.scrollLeft = scrollPosition;
        }, 100);

    } catch (error) {
        console.error('Error rating review:', error);
        showNotification('Ошибка при оценке отзыва', 'error');
    }
}

// Функция добавления оценки
function addRating(review, isLike) {
    if (isLike) {
        review.likes = (review.likes || 0) + 1;
    } else {
        review.dislikes = (review.dislikes || 0) + 1;
    }
}

// Функция удаления оценки
function removeRating(review, isLike) {
    if (isLike) {
        review.likes = Math.max(0, (review.likes || 0) - 1);
    } else {
        review.dislikes = Math.max(0, (review.dislikes || 0) - 1);
    }
}

// Функция проверки оценки пользователя
function getUserRating(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review || !review.user_ratings) return null;

    return review.user_ratings[userToken] || null;
}

// Функция обновления UI
function updateRatingUI(reviewId, likes, dislikes) {
    // Обновляем только модальное окно (лайки/дизлайки теперь только там)
    const modal = document.getElementById('full-review-modal');
    if (modal && modal.dataset.reviewId == reviewId) {
        const likeCountElem = modal.querySelector('.like-count');
        const dislikeCountElem = modal.querySelector('.dislike-count');
        const likeBtn = modal.querySelector('.like-btn');
        const dislikeBtn = modal.querySelector('.dislike-btn');

        if (likeCountElem) likeCountElem.textContent = likes || 0;
        if (dislikeCountElem) dislikeCountElem.textContent = dislikes || 0;

        // Убираем все активные состояния
        if (likeBtn) likeBtn.classList.remove('active');
        if (dislikeBtn) dislikeBtn.classList.remove('active');

        // Подсвечиваем активную оценку пользователя с вашими стилями
        const userRating = getUserRating(reviewId);
        if (userRating === 'like' && likeBtn) {
            likeBtn.classList.add('active');
        } else if (userRating === 'dislike' && dislikeBtn) {
            dislikeBtn.classList.add('active');
        }
    }

    // Обновляем данные в карточке отзыва (только данные, без UI)
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        reviewElement.dataset.likes = likes || 0;
        reviewElement.dataset.dislikes = dislikes || 0;
    }
}

// Функция для полного сброса оценки пользователя
function resetUserRating(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review || !review.user_ratings) return;

    const userRating = review.user_ratings[userToken];
    if (!userRating) return;

    // Удаляем оценку
    if (userRating === 'like') {
        review.likes = Math.max(0, (review.likes || 0) - 1);
    } else {
        review.dislikes = Math.max(0, (review.dislikes || 0) - 1);
    }

    // Удаляем запись о оценке
    delete review.user_ratings[userToken];

    // Обновляем UI
    updateRatingUI(reviewId, review.likes, review.dislikes);
    saveRatingsToStorage();

    showNotification('Оценка сброшена!');
}

// ===== ИНИЦИАЛИЗАЦИЯ =====

// В функции loadReviews() добавьте:
// Вызовите эту функцию после загрузки отзывов
async function loadReviews() {
    try {
        console.log('Loading reviews for restaurant:', currentRestaurantId);
        const response = await fetch(`/api/reviews?restaurant_id=${currentRestaurantId}`);

        if (response.ok) {
            const reviewsData = await response.json();
            console.log('Received reviews data:', reviewsData);

            reviews = reviewsData;
            applyStoredRatings();
            displayReviews(reviews);

            // ДЕБАГ: проверяем данные
            debugReviews();
        } else {
            console.error('Failed to load reviews:', response.status);
            throw new Error('Ошибка загрузки отзывов');
        }
    } catch (error) {
        console.error('Error loading reviews:', error);
    }
}

// Функция для проверки данных отзывов
function debugReviews() {
    console.log('=== DEBUG REVIEWS ===');
    console.log('Current user token:', userToken);
    console.log('All reviews:', reviews);

    reviews.forEach((review, index) => {
        console.log(`Review ${index}:`, {
            id: review.id,
            user_token: review.user_token,
            device_fingerprint: review.device_fingerprint,
            canEdit: checkEditPermission(review)
        });
    });
}

// ===== ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ =====

// Функция для разворачивания/сворачивания текста
function toggleReviewExpand(reviewId) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (!reviewElement) return;

    reviewElement.classList.toggle('expanded');

    const button = reviewElement.querySelector('.expand-btn-bottom');
    if (button) {
        if (reviewElement.classList.contains('expanded')) {
            button.textContent = 'Свернуть';
        } else {
            button.textContent = 'Развернуть';
        }
    }
}

// Установка рейтинга при редактировании
function setRating(starElement, rating) {
    const starsContainer = starElement.closest('.stars');
    const stars = starsContainer.querySelectorAll('.star');

    stars.forEach((star, index) => {
        const starValue = parseInt(star.getAttribute('data-value'));
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★" style="width:24px;height:24px;">`;
    });

    // Сохраняем выбранный рейтинг
    starsContainer.dataset.rating = rating;
}

function resetReviewForm() {
    document.getElementById('review-form').reset();
    // Сбрасываем звезды рейтинга
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });
    selectedRating = 0;
    document.getElementById('rating-error').style.display = 'none';
}

// Инициализация статистики при загрузке страницы
async function initStats() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurantId}/stats`);
        if (!response.ok) {
            throw new Error('Ошибка при загрузке статистики');
        }
        const stats = await response.json();
        updateRatingStats(stats);
    } catch (error) {
        console.error('Error:', error);
        // Устанавливаем значения по умолчанию
        document.getElementById('overall-rating').textContent = '0.0';
        document.getElementById('total-reviews').textContent = '0';

        // Сбрасываем все бары
        for (let i = 1; i <= 5; i++) {
            const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
            const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);
            if (bar) bar.style.width = '0%';
            if (countSpan) countSpan.textContent = '0';
        }
    }
}

// Локальное обновление статистики после добавления отзыва
function updateStatsLocally(newRating) {
    // Обновляем общее количество отзывов
    const totalReviewsElem = document.getElementById('total-reviews');
    const currentTotal = parseInt(totalReviewsElem.textContent) || 0;
    totalReviewsElem.textContent = currentTotal + 1;

    // Обновляем общий рейтинг
    const overallRatingElem = document.getElementById('overall-rating');
    const currentRating = parseFloat(overallRatingElem.textContent) || 0;
    const newOverallRating = ((currentRating * currentTotal) + newRating) / (currentTotal + 1);
    overallRatingElem.textContent = newOverallRating.toFixed(1);

    // Обновляем счетчик для конкретного рейтинга
    const ratingBars = document.querySelectorAll('.rating-bar');
    const targetBarIndex = 6 - newRating; // Индекс бара для этого рейтинга
    const targetBar = ratingBars[targetBarIndex - 1];

    if (targetBar) {
        const countSpan = targetBar.querySelector('span:last-child');
        const currentCount = parseInt(countSpan.textContent) || 0;
        countSpan.textContent = currentCount + 1;

        // Обновляем ширину заполнения
        const barFill = targetBar.querySelector('.fill');
        const newTotal = currentTotal + 1;
        const newPercentage = ((currentCount + 1) / newTotal) * 100;
        barFill.style.width = `${newPercentage}%`;
    }

    // Также обновляем все остальные бары (проценты меняются)
    updateAllBarsPercentages(currentTotal + 1);
}

// Функция для обновления процентов всех баров
function updateAllBarsPercentages(totalReviews) {
    if (totalReviews === 0) return;

    for (let i = 1; i <= 5; i++) {
        const barIndex = 6 - i;
        const bar = document.querySelector(`.rating-bar:nth-child(${barIndex})`);

        if (bar) {
            const countSpan = bar.querySelector('span:last-child');
            const count = parseInt(countSpan.textContent) || 0;
            const percentage = (count / totalReviews) * 100;

            const barFill = bar.querySelector('.fill');
            barFill.style.width = `${percentage}%`;
        }
    }
}

// Обработчик изменения размера окна
// При полной загрузке окна
window.addEventListener('load', function() {
    console.log('Window fully loaded - updating scroll');
    setTimeout(updateScrollButtons, 300);
});

// При изменении размера окна
window.addEventListener('resize', function() {
    setTimeout(updateScrollButtons, 200);
});

// При любых изменениях DOM (MutationObserver)
const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
            setTimeout(updateScrollButtons, 100);
        }
    });
});

// Начинаем наблюдение
const reviewList = document.getElementById('review-list');
if (reviewList) {
    observer.observe(reviewList, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style']
    });
}

// Функция для обновления общего рейтинга (только для синхронизации)
async function updateOverallRating() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurantId}/stats`);
        if (!response.ok) return; // Не бросаем ошибку, т.к. это фоновое обновление

        const stats = await response.json();
        updateRatingStats(stats);
    } catch (error) {
        console.error('Error updating overall rating:', error);
        // Не показываем уведомление, т.к. это фоновый процесс
    }
}

// Вызываем эту функцию при загрузке страницы и после добавления отзыва
document.addEventListener('DOMContentLoaded', () => {
    updateOverallRating();
    loadReviews();
});

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    // Инициализация звезд рейтинга
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));
            stars.forEach((s, index) => {
                s.innerHTML = `<img src="${index < selectedRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
            });
            document.getElementById('rating-error').style.display = 'none';
        });
    });

    // Загрузка отзывов
    loadReviews();
});


















// Функция для показа уведомлений
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Абсолютно надежная функция закрытия
function closeReviewModal() {
    const modal = document.getElementById('review-modal');
    if (modal) {
        modal.style.display = 'none';
    }

    // Сбрасываем форму
    const form = document.getElementById('review-form');
    if (form) {
        form.reset();
    }

    // Сбрасываем звезды
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });

    selectedRating = 0;
}








// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    loadReviews();
});

function initFavorites() {
  updateFavoritesVisibility();

  window.addEventListener('storage', function(event) {
    if (event.key === 'favorites') {
      updateFavoritesVisibility();
    }
  });
}

// Основная функция переключения
function toggleFavorite(itemId, itemData) {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};

  if (favorites[itemId]) {
    delete favorites[itemId];
  } else {
    favorites[itemId] = itemData;
  }

  localStorage.setItem('favorites', JSON.stringify(favorites));

  // Принудительное обновление интерфейса
  forceUIUpdate();

  // Оповещение других вкладок
  window.dispatchEvent(new Event('storageUpdate'));
}

// Обновление интерфейса с анимацией
function forceUIUpdate() {
  const headerBtn = document.getElementById('header-favorites-btn');
  if (headerBtn) {
    // 1. Добавляем класс для анимации исчезновения
    headerBtn.classList.add('hide');

    // 2. Через 300ms (длительность анимации) обновляем состояние
    setTimeout(() => {
      updateFavoritesVisibility();
      headerBtn.classList.remove('hide');
    }, 300);
  } else {
    updateFavoritesVisibility();
  }
}

// Контроль видимости кнопки
function updateFavoritesVisibility() {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};
  const count = Object.keys(favorites).length;
  const headerBtn = document.getElementById('header-favorites-btn');
  const counter = document.getElementById('favorites-count');

  if (counter) counter.textContent = count;

  if (!headerBtn) return;

  if (count > 0) {
    showHeaderButton();
  } else {
    hideHeaderButton();
  }
}

// Показать кнопку в шапке
function showHeaderButton() {
  const btn = document.getElementById('header-favorites-btn');
  if (!btn.classList.contains('visible')) {
    btn.style.display = 'inline-block';
    setTimeout(() => {
      btn.classList.add('visible');
    }, 10);
  }
}

// Скрыть кнопку с анимацией
function hideHeaderButton() {
  const btn = document.getElementById('header-favorites-btn');
  if (btn.classList.contains('visible')) {
    btn.classList.remove('visible');
    setTimeout(() => {
      btn.style.display = 'none';
    }, 300); // Должно совпадать с длительностью transition
  }
}

// Обновление счетчика и видимости кнопки
function updateFavoritesCount() {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};
  const count = Object.keys(favorites).length;
  const counter = document.getElementById('favorites-count');
  const headerBtn = document.getElementById('header-favorites-btn');

  if (counter) counter.textContent = count;

  if (headerBtn) {
    if (count > 0) {
      showHeaderButton();
    } else {
      hideHeaderButton();
    }
  }
}


    // Функции для окон входа/регистрации
    function showWindow() {
        document.getElementById('overlay').style.display = 'block';
        const windowElement = document.getElementById('content_window');
        windowElement.classList.add('show');
        windowElement.style.display = 'block';
        document.body.classList.add('no-scroll');
    }

    function hideWindow() {
        document.getElementById('overlay').style.display = 'none';
        const windowElement = document.getElementById('content_window');
        windowElement.classList.remove('show');
        windowElement.style.display = 'none';
        document.body.classList.remove('no-scroll');
    }

    function showWindow1() {
        document.getElementById('overlay').style.display = 'block';
        const windowElement = document.getElementById('content_window2');
        windowElement.classList.add('show');
        windowElement.style.display = 'block';
        document.body.classList.add('no-scroll');
    }

    function hideWindow1() {
        document.getElementById('overlay').style.display = 'none';
        const windowElement = document.getElementById('content_window2');
        windowElement.classList.remove('show');
        windowElement.style.display = 'none';
        document.body.classList.remove('no-scroll');
    }

    // Закрытие окна при клике вне его
    document.getElementById('overlay').addEventListener('click', function() {
        const window1 = document.getElementById('content_window');
        const window2 = document.getElementById('content_window2');
        if (window1.classList.contains('show')) {
            hideWindow();
        } else if (window2.classList.contains('show')) {
            hideWindow1();
        }
    });

    // Обработчик для формы регистрации
    document.getElementById('regForm').onsubmit = function(event) {
        event.preventDefault();

        const username = document.getElementById('username1').value;
        const password = document.getElementById('password1').value;
        const confirmPassword = document.getElementById('password2').value;
        const secretKey = document.getElementById('secret_key').value;

        if (password !== confirmPassword) {
            alert('Пароли не совпадают');
            return;
        }

        fetch('/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'username': username,
                'password': password,
                'secret_key': secretKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('welcomeUser').innerText = data.username;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
                hideWindow1();
                localStorage.setItem('username', data.username);
            } else {
                alert(data.message);
            }
        });
    };

    // Обработчик для формы входа
    document.getElementById('loginForm').onsubmit = function(event) {
        event.preventDefault();

        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;

        fetch('/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'username': username,
                'password': password
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('welcomeUser').innerText = data.username;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
                hideWindow();
                localStorage.setItem('username', data.username);
            } else {
                alert(data.message);
            }
        });
    };

    // Функция выхода
    function logout() {
        fetch('/logout', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('loginButton').style.display = 'block';
                document.getElementById('registerButton').style.display = 'block';
                localStorage.removeItem('username');
            } else {
                alert(data.message);
            }
        });
    }

    // Проверка состояния пользователя при загрузке страницы
    window.addEventListener('load', function() {
        const username = localStorage.getItem('username');
        if (username) {
            document.getElementById('welcomeUser').innerText = username;
            document.getElementById('userInfo').style.display = 'flex';
            document.getElementById('loginButton').style.display = 'none';
            document.getElementById('registerButton').style.display = 'none';
        }

        // Инициализация менеджера избранного
        FavoritesManager.init();
    });

    // Синхронизация состояния пользователя между вкладками
    window.addEventListener('storage', function(event) {
        if (event.key === 'username') {
            if (event.newValue) {
                document.getElementById('welcomeUser').innerText = event.newValue;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
            } else {
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('loginButton').style.display = 'block';
                document.getElementById('registerButton').style.display = 'block';
            }
        }
    });

    // Менеджер избранного из старого HTML
    const FavoritesManager = {
        init: function() {
            this.bindEvents();
            this.updateCounter();
            this.markExistingFavorites();
        },

        bindEvents: function() {
            document.querySelectorAll('.js-favorite-btn').forEach(btn => {
                btn.addEventListener('click', this.handleFavoriteClick.bind(this));
            });
        },

        handleFavoriteClick: function(event) {
            const button = event.currentTarget;
            if (!button) return;

            try {
                const itemData = button.getAttribute('data-item');
                if (!itemData) {
                    console.error('No data-item attribute found');
                    return;
                }

                const item = JSON.parse(itemData);
                if (!item || !item.id) {
                    console.error('Invalid item data');
                    return;
                }

                const favorites = this.getFavorites();
                const existingIndex = favorites.findIndex(fav => fav.id === item.id);

                if (existingIndex === -1) {
                    favorites.push(item);
                    button.classList.add('active');
                    this.showNotification(`"${item.name}" добавлен в избранное`);
                } else {
                    favorites.splice(existingIndex, 1);
                    button.classList.remove('active');
                    this.showNotification(`"${item.name}" удален из избранного`);
                }

                this.saveFavorites(favorites);
                this.updateCounter();
            } catch (error) {
                console.error('Error handling favorite click:', error);
            }
        },

        markExistingFavorites: function() {
            const favorites = this.getFavorites();
            document.querySelectorAll('.js-favorite-btn').forEach(btn => {
                try {
                    const itemData = btn.getAttribute('data-item');
                    if (!itemData) return;

                    const item = JSON.parse(itemData);
                    if (item && item.id && favorites.some(fav => fav.id === item.id)) {
                        btn.classList.add('active');
                    }
                } catch (error) {
                    console.error('Error marking existing favorite:', error);
                }
            });
        },

        getFavorites: function() {
            try {
                return JSON.parse(localStorage.getItem('favorites')) || [];
            } catch (error) {
                console.error('Error getting favorites:', error);
                return [];
            }
        },

        saveFavorites: function(favorites) {
            try {
                localStorage.setItem('favorites', JSON.stringify(favorites));
            } catch (error) {
                console.error('Error saving favorites:', error);
            }
        },

        updateCounter: function() {
            try {
                const count = this.getFavorites().length;
                const counter = document.getElementById('favorites-count');
                if (counter) counter.textContent = count;
            } catch (error) {
                console.error('Error updating counter:', error);
            }
        },

        showNotification: function(message) {
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = 'rgba(0,0,0,0.8)';
            notification.style.color = 'white';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '5px';
            notification.style.zIndex = '1000';
            notification.style.transition = 'opacity 0.5s';
            notification.textContent = message;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }
    };

    // Переворот карточки
    function flipCard() {
        document.querySelector('.image-flip-container').classList.toggle('flipped');
    }

    // Развернуть изображение
    function expandImage(btn) {
        const img = btn.closest('.image-front').querySelector('img');
        const imgSrc = img.src;

        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.9)';
        overlay.style.display = 'flex';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '1000';
        overlay.style.cursor = 'zoom-out';

        const expandedImg = document.createElement('img');
        expandedImg.src = imgSrc;
        expandedImg.style.maxWidth = '90%';
        expandedImg.style.maxHeight = '90%';
        expandedImg.style.objectFit = 'contain';

        overlay.appendChild(expandedImg);
        overlay.onclick = function() {
            document.body.removeChild(overlay);
        };

        document.body.appendChild(overlay);
    }

    // Модальное окно для меню
    function openMenuModal() {
        document.getElementById('menu-modal').style.display = 'flex';
    }
    function closeMenuModal() {
        document.getElementById('menu-modal').style.display = 'none';
    }

    // Модальное окно для отзыва
    function openReviewModal() {
        // Генерируем/проверяем токен ДО открытия окна
        if (!localStorage.getItem('userToken')) {
            userToken = generateUserToken();
        }

        document.getElementById('review-modal').style.display = 'flex';
    }
    // Закрытие модального окна при клике вне его области
    document.getElementById('review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReviewModal();
        }
    });

    // Обработчик для кнопки закрытия
    document.querySelector('#review-modal .close').addEventListener('click', function() {
        closeReviewModal();
    });

    function filterReviewsByRating(rating) {
    const reviewList = document.getElementById('review-list');
    const reviewCards = reviewList.querySelectorAll('.review-card');
    let hasMatches = false;

    // Удаляем старое сообщение "Нет отзывов"
    const oldMsg = document.getElementById('no-reviews-message');
    if (oldMsg) oldMsg.remove();

    // Фильтруем отзывы (включая те, что еще не в БД)
    reviewCards.forEach(card => {
        // Ищем рейтинг двумя способами (для отзывов из БД и новых)
        let cardRating;

        // Способ 1: По заполненным звездам (работает для всех отзывов)
        const filledStars = card.querySelectorAll('.review-rating img[src*="baka.png"]');
        if (filledStars.length > 0) {
            cardRating = filledStars.length;
        }
        // Способ 2: По data-атрибуту (для новых отзывов)
        else {
            const ratingElem = card.querySelector('.rating');
            cardRating = ratingElem ? parseInt(ratingElem.dataset.rating) : 0;
        }

        if (rating === 0 || cardRating === rating) {
            card.style.display = 'flex';
            hasMatches = true;
        } else {
            card.style.display = 'none';
        }
    });

    // Показываем сообщение если нет совпадений
    if (!hasMatches && rating !== 0) {
        const msg = document.createElement('div');
        msg.id = 'no-reviews-message';
        msg.textContent = 'Таких отзывов нет!';
        msg.style.textAlign = 'center';
        msg.style.padding = '20px';
        msg.style.color = '#666';
        msg.style.width = '100%';
        reviewList.appendChild(msg);
    }

    // Всегда обновляем кнопки прокрутки после фильтрации
    setTimeout(updateScrollButtons, 150);
}

    // Обновленный обработчик звезд фильтра
    const filterStars = document.querySelectorAll('#filter-stars .star');
    let currentFilter = {
        rating: 0,      // Фильтр по звездам (0 - все)
        reaction: 'none' // Фильтр по реакциям ('none', 'likes', 'dislikes')
    };

    filterStars.forEach(star => {
        star.addEventListener('click', function() {
            const value = parseInt(this.getAttribute('data-value'));

            // Если кликнули на уже выбранную звезду - сбрасываем фильтр
            if (currentFilter === value) {
                currentFilter = 0;
                filterStars.forEach(s => {
                    s.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
                });
            } else {
                currentFilter = value;
                // Подсвечиваем звезды до выбранного значения
                filterStars.forEach((s, index) => {
                    const starValue = index + 1;
                    s.innerHTML = `<img src="${starValue <= value ? PATHS.starActive : PATHS.starInactive}"
                                       alt="★">`;
                });
            }

            filterReviewsByRating(currentFilter);
        });
    });

    // Обработчики для кнопок реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const filterType = this.getAttribute('data-type');

            // Если кликаем на уже активную кнопку - сбрасываем
            if (currentFilter.reaction === filterType) {
                currentFilter.reaction = 'none';
                filterButtons.forEach(b => b.classList.remove('active'));
                document.querySelector('.filter-btn[data-type="none"]').classList.add('active');
            } else {
                // Устанавливаем новый фильтр
                currentFilter.reaction = filterType;
                filterButtons.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            }

            applyFilters();
        });
    });


    // Функция показа всех отзывов
    function showAllReviews() {
        currentFilter = 0;
        filterStars.forEach(star => {
            star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
        });
        filterReviewsByRating(0);
    }

    // Лайки и дизлайки
    let likeCount = 0;
    let dislikeCount = 0;
    function likeReview() {
        likeCount++;
        document.getElementById('like-count').textContent = likeCount;
    }
    function dislikeReview() {
        dislikeCount++;
        document.getElementById('dislike-count').textContent = dislikeCount;
    }

    // Оценка звёздами
    const stars = document.querySelectorAll('#review-stars .star');

    stars.forEach(star => {
        star.addEventListener('click', () => {
            const value = parseFloat(star.getAttribute('data-value'));
            selectedRating = value; // Сохраняем выбранную оценку

            stars.forEach((s, index) => {
                const starValue = parseFloat(s.getAttribute('data-value'));
                if (starValue <= value) {
                    s.innerHTML = `<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★" style="width: 24px; height: 24px;">`;
                } else {
                    s.innerHTML = `<img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★" style="width: 24px; height: 24px;">`;
                }
            });
        });
    });


    reviewList.scrollTo({
        left: 0,
        behavior: 'smooth'
    });

    // Закрытие модального окна при клике вне его области
    document.getElementById('full-review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeFullReviewModal();
        }
    });

    // Функция закрытия модального окна
    function closeFullReviewModal() {
        document.getElementById('full-review-modal').style.display = 'none';
    }

// Функция открытия модального окна с полным отзывом
function openFullReviewModal(reviewId) {
    console.log('Opening full review modal for ID:', reviewId);

    // Ищем отзыв в глобальном массиве
    const reviewData = reviews.find(r => r.id == reviewId);
    if (!reviewData) {
        console.error('Review not found:', reviewId);
        showNotification('Отзыв не найден', 'error');
        return;
    }

    const modal = document.getElementById('full-review-modal');
    if (!modal) {
        console.error('Modal not found');
        return;
    }

    // Создаем HTML для звезд рейтинга
    let starsHTML = '';
    for (let i = 0; i < 5; i++) {
        if (i < reviewData.rating) {
            starsHTML += `<img src="${PATHS.starActive}" alt="★" style="width:20px;height:20px;">`;
        } else {
            starsHTML += `<img src="${PATHS.starInactive}" alt="★" style="width:20px;height:20px;">`;
        }
    }

    // Заполняем модальное окно
    const reviewNameElem = modal.querySelector('.review-name');
    const reviewRatingElem = modal.querySelector('.review-rating');
    const reviewCommentElem = modal.querySelector('.review-comment');
    const likeCountElem = modal.querySelector('.like-count');
    const dislikeCountElem = modal.querySelector('.dislike-count');
    const likeBtn = modal.querySelector('.like-btn');
    const dislikeBtn = modal.querySelector('.dislike-btn');

    if (reviewNameElem) reviewNameElem.textContent = reviewData.username;
    if (reviewRatingElem) reviewRatingElem.innerHTML = starsHTML;
    if (reviewCommentElem) reviewCommentElem.textContent = reviewData.comment;
    if (likeCountElem) likeCountElem.textContent = reviewData.likes || 0;
    if (dislikeCountElem) dislikeCountElem.textContent = reviewData.dislikes || 0;

    // ОБНОВЛЯЕМ ОБРАБОТЧИКИ КНОПОК
    if (likeBtn) {
        likeBtn.onclick = () => rateReview(true, reviewId);
    }
    if (dislikeBtn) {
        dislikeBtn.onclick = () => rateReview(false, reviewId);
    }

    // ДОБАВЛЯЕМ КНОПКУ РЕДАКТИРОВАНИЯ
    addEditButtonToModal(modal, reviewData);

    // Сохраняем ID отзыва
    modal.dataset.reviewId = reviewId;

    // Показываем модальное окно
    modal.style.display = 'flex';
    console.log('Modal displayed');
}

    // При создании отзыва добавляем поле для отслеживания голосов
    const review = {
        id: Date.now(),
        name: name,
        rating: selectedRating,
        comment: comment,
        likes: 0,
        dislikes: 0,
        userVoted: null // 'like', 'dislike' или null
    };

    // Функция для добавления кнопки редактирования в модальное окно
function addEditButtonToModal(modal, reviewData) {
    console.log('Adding edit button for review:', reviewData);

    // Удаляем старую кнопку редактирования если есть
    const oldEditBtn = modal.querySelector('.edit-review-btn');
    if (oldEditBtn) {
        oldEditBtn.remove();
    }

    // Проверяем можно ли редактировать отзыв
    const canEdit = checkEditPermission(reviewData);
    console.log('Can edit:', canEdit);

    // Создаем контейнер для кнопок
    let buttonsContainer = modal.querySelector('.modal-buttons-container');
    if (!buttonsContainer) {
        buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'modal-buttons-container';
        modal.querySelector('.modal-content').appendChild(buttonsContainer);
    }

    // Создаем кнопку редактирования
    const editButton = document.createElement('button');
    editButton.className = `edit-review-btn ${canEdit ? '' : 'disabled'}`;
    editButton.innerHTML = '✏️ Редактировать';
    editButton.dataset.reviewId = reviewData.id;

    if (canEdit) {
        editButton.onclick = () => {
            console.log('Edit button clicked for review:', reviewData.id);
            openEditReviewModal(reviewData.id, reviewData.rating, reviewData.comment);
        };
    } else {
        editButton.onclick = () => {
            console.log('Edit button clicked but disabled for review:', reviewData.id);
            showEditTimeExpiredMessage(reviewData);
        };
        editButton.title = 'Время редактирования истекло или недоступно';
    }

    buttonsContainer.appendChild(editButton);
    console.log('Edit button added:', editButton);
}

// Функция показа сообщения об истечении времени редактирования
function showEditTimeExpiredMessage(review) {
    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    let message;

    if (hoursDiff > 3) {
        message = 'У тебя было 3 часа чтобы всё исправить. Время редактирования истекло!';
    } else if (review.user_token !== userToken) {
        message = 'Это не твой отзыв! Редактирование запрещено.';
    } else if (!isSameDevice(review)) {
        message = 'Редактирование разрешено только с того же устройства!';
    } else {
        message = 'Редактирование невозможно по неизвестной причине.';
    }

    showNotification(message, 'error');

    // Анимация кнопки
    const editButton = document.querySelector('#full-review-modal .edit-review-btn');
    if (editButton) {
        editButton.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
            editButton.style.animation = '';
        }, 500);
    }
}

// Функция для принудительного обновления счетчиков
function updateCountersManually() {
    const modal = document.getElementById('full-review-modal');
    if (!modal) return;

    const reviewId = modal.dataset.reviewId;
    if (!reviewId) return;

    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    const reviewData = reviews.find(r => r.id == reviewId);

    if (reviewData) {
        const likeCountElem = modal.querySelector('.like-count');
        const dislikeCountElem = modal.querySelector('.dislike-count');

        if (likeCountElem) likeCountElem.textContent = reviewData.likes || 0;
        if (dislikeCountElem) dislikeCountElem.textContent = reviewData.dislikes || 0;

        if (reviewElement) {
            reviewElement.dataset.likes = reviewData.likes || 0;
            reviewElement.dataset.dislikes = reviewData.dislikes || 0;
        }
    }
}

// Вызовите эту функцию если нужно принудительно обновить

    // Функция для ограничения высоты текста
    // Функция для ограничения высоты длинных комментариев
function limitCommentHeight(reviewElement) {
    const container = reviewElement.querySelector('.comment-container');
    const text = reviewElement.querySelector('.comment-text');
    const blur = reviewElement.querySelector('.comment-blur');

    if (text.scrollHeight > text.clientHeight) {
        blur.style.display = 'block';
    } else {
        blur.style.display = 'none';
    }
}

    // Общая оценка и статистика
    let overallRating = 0;
    let ratingCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

    // Функция для обновления статистики отзывов
    function updateRatingBars() {
        const totalReviews = reviews.length;
        for (let i = 1; i <= 5; i++) {
            const count = ratingCounts[i];
            const percentage = totalReviews === 0 ? 0 : (count / totalReviews) * 100;
            const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
            const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);
            bar.style.width = `${percentage}%`;
            countSpan.textContent = count;
        }
    }

    // Функция для прокрутки отзывов
function scrollReviews(direction) {
    const reviewList = document.getElementById('review-list');
    const scrollAmount = 320; // Фиксированное значение

    if (direction === 'left') {
        reviewList.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
    } else {
        reviewList.scrollBy({ left: scrollAmount, behavior: 'smooth' });
    }

    // Обновляем кнопки после прокрутки
    setTimeout(updateScrollButtons, 350);
}

function updateScrollButtons() {
    const reviewList = document.getElementById('review-list');
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!reviewList || !leftButton || !rightButton) {
        console.log('Scroll elements not found');
        return;
    }

    // Ждем следующего tick'а для обновления DOM
    setTimeout(() => {
        try {
            // Проверяем видимые отзывы
            const visibleReviews = Array.from(reviewList.children).filter(card =>
                card.style.display !== 'none' && window.getComputedStyle(card).display !== 'none'
            );

            const hasVisibleReviews = visibleReviews.length > 0;
            const canScroll = reviewList.scrollWidth > reviewList.clientWidth + 2; // +2 для погрешности

            console.log('Scroll state:', {
                visibleReviews: visibleReviews.length,
                scrollWidth: reviewList.scrollWidth,
                clientWidth: reviewList.clientWidth,
                canScroll: canScroll,
                scrollLeft: reviewList.scrollLeft
            });

            if (hasVisibleReviews && canScroll) {
                // Показываем кнопки
                leftButton.style.display = 'flex';
                rightButton.style.display = 'flex';

                // Обновляем состояния
                const canScrollLeft = reviewList.scrollLeft > 5;
                const canScrollRight = reviewList.scrollLeft + reviewList.clientWidth < reviewList.scrollWidth - 5;

                leftButton.style.opacity = canScrollLeft ? '1' : '0.3';
                rightButton.style.opacity = canScrollRight ? '1' : '0.3';
                leftButton.style.pointerEvents = canScrollLeft ? 'auto' : 'none';
                rightButton.style.pointerEvents = canScrollRight ? 'auto' : 'none';
            } else {
                // Скрываем кнопки
                leftButton.style.display = 'none';
                rightButton.style.display = 'none';
            }
        } catch (error) {
            console.error('Error in updateScrollButtons:', error);
        }
    }, 50);
}

    // Обновленная функция для обновления видимости отзывов и кнопок
    function updateReviewVisibility() {
        const reviewList = document.getElementById('review-list');
        const visibleReviews = Array.from(reviewList.querySelectorAll('.review-card'))
            .filter(card => window.getComputedStyle(card).display !== 'none');

        const leftButton = document.querySelector('.scroll-button.left');
        const rightButton = document.querySelector('.scroll-button.right');

        // Проверяем возможность прокрутки
        const canScrollLeft = reviewList.scrollLeft > 0;
        const canScrollRight = reviewList.scrollLeft + reviewList.clientWidth < reviewList.scrollWidth;

        // Управляем видимостью и состоянием кнопок
        if (visibleReviews.length === 0) {
            leftButton.style.opacity = '0';
            leftButton.style.pointerEvents = 'none';
            rightButton.style.opacity = '0';
            rightButton.style.pointerEvents = 'none';
        } else {
            leftButton.style.opacity = canScrollLeft ? '1' : '0.5';
            leftButton.style.pointerEvents = canScrollLeft ? 'auto' : 'none';

            rightButton.style.opacity = canScrollRight ? '1' : '0.5';
            rightButton.style.pointerEvents = canScrollRight ? 'auto' : 'none';
        }
    }

// Обновление состояния стрелочек при прокрутке
reviewList.addEventListener('scroll', function() {
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!leftButton || !rightButton) return;

    const canScrollLeft = this.scrollLeft > 0;
    const canScrollRight = this.scrollLeft + this.clientWidth < this.scrollWidth - 1;

    leftButton.style.opacity = canScrollLeft ? '1' : '0.5';
    leftButton.style.pointerEvents = canScrollLeft ? 'auto' : 'none';

    rightButton.style.opacity = canScrollRight ? '1' : '0.5';
    rightButton.style.pointerEvents = canScrollRight ? 'auto' : 'none';
});

    // Функция для разворачивания отзыва
function expandReview(reviewId) {
    const review = reviews.find(r => r.id === reviewId);
    if (!review) return;

    const modal = document.getElementById('full-review-modal');
    modal.querySelector('.review-name').textContent = review.username;
    modal.querySelector('.review-rating').innerHTML =
        `${'<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★" style="width:20px;height:20px;">'.repeat(review.rating)}`;
    modal.querySelector('.review-comment').textContent = review.comment;
    modal.style.display = 'flex';
}

// Глобальные переменные
let currentUser = null; // Должно устанавливаться при авторизации
let currentRestaurant = {
    id: 'lambs',
    name: 'Барашки'
};

// Функция для проверки можно ли редактировать отзыв
function checkReviewEditAbility(review) {
    if (!review.can_edit) return false;

    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    return hoursDiff <= 3;
}

// Функция для загрузки данных ресторана и отзывов
async function loadRestaurantData() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurant.id}`);
        const data = await response.json();

        if (!response.ok) {
            throw new Error('Ошибка при загрузке данных');
        }

        // Обновляем рейтинг ресторана
        updateRestaurantRating(data.restaurant.rating, data.restaurant.review_count);

        // Очищаем и добавляем отзывы
        document.getElementById('reviews-list').innerHTML = '';
        data.reviews.forEach(review => {
            addReviewToUI(review);
        });
    } catch (error) {
        showNotification(error.message, 'error');
    }
}

// Вспомогательные функции для обновления UI
function updateRestaurantRating(rating, count) {
    if (rating) {
        document.querySelector('.overall-rating .rating-value').textContent = rating.toFixed(1);
        document.querySelector('.restaurant-rating .rating-value').textContent = rating.toFixed(1);
    }
    if (count) {
        document.querySelector('.overall-rating .reviews-count').textContent = `${count} отзывов`;
    }
}

function addReviewToUI(review) {
    const reviewsContainer = document.getElementById('review-list');

    // Удаляем сообщение "Нет отзывов", если оно есть
    const noReviewsMsg = reviewsContainer.querySelector('.no-reviews');
    if (noReviewsMsg) {
        noReviewsMsg.remove();
    }

    const reviewElement = document.createElement('div');
    reviewElement.className = 'review-card';
    reviewElement.dataset.reviewId = review.id;

    reviewElement.innerHTML = `
        <div class="review-header">
            <img class="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Аватар">
            <div class="name-rating">
                <div class="name">${review.username}</div>
                <div class="rating">
                    ${'<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★">'.repeat(review.rating)}
                    ${'<img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">'.repeat(5 - review.rating)}
                </div>
            </div>
        </div>
        <div class="comment-container">
            <div class="comment-text">${review.comment || ''}</div>
        </div>
        <div class="review-actions">
            <button class="like-btn" onclick="rateReview(${review.id}, true)">
                <img src="{{ url_for('static', filename='Фотки зданий/Лайк.png') }}" alt="Лайк">
                <span class="like-count">${review.likes}</span>
            </button>
            <button class="dislike-btn" onclick="rateReview(${review.id}, false)">
                <img src="{{ url_for('static', filename='Фотки зданий/Дизлайк.png') }}" alt="Дизлайк">
                <span class="dislike-count">${review.dislikes}</span>
            </button>
        </div>
        <div class="review-date">${new Date(review.created_at).toLocaleString()}</div>
    `;

    // Добавляем новый отзыв в начало списка
    reviewsContainer.insertBefore(reviewElement, reviewsContainer.firstChild);

    // Добавляем анимацию появления
    reviewElement.style.opacity = '0';
    setTimeout(() => {
        reviewElement.style.transition = 'opacity 0.3s ease';
        reviewElement.style.opacity = '1';
    }, 10);
}

function updateReviewInUI(reviewId, updatedData) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (!reviewElement) return;

    if (updatedData.rating) {
        const ratingElement = reviewElement.querySelector('.review-rating');
        ratingElement.innerHTML = `
            ${'<svg viewBox="0 0 24 24" class="star-icon filled"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>'.repeat(updatedData.rating)}
            <span>${updatedData.rating.toFixed(1)}</span>
        `;
    }

    if (updatedData.comment !== undefined) {
        const commentElement = reviewElement.querySelector('.review-content p');
        commentElement.textContent = updatedData.comment || '';
    }

    // Обновляем дату редактирования
    if (updatedData.updated_at) {
        const dateElement = reviewElement.querySelector('.review-date');
        dateElement.textContent = `${formatDate(updatedData.updated_at)} (изменен)`;
    }

    // Проверяем можно ли еще редактировать
    const canEdit = checkReviewEditAbility({
        created_at: reviewElement.querySelector('.review-date').dataset.originalDate,
        can_edit: true
    });

    if (!canEdit) {
        const editButtons = reviewElement.querySelector('.review-edit-buttons');
        if (editButtons) editButtons.remove();
    }
}

function removeReviewFromUI(reviewId) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        reviewElement.classList.add('fade-out');
        setTimeout(() => reviewElement.remove(), 300);
    }
}

// Функция открытия модального окна редактирования
function openEditReviewModal(reviewId, currentRating, currentComment) {
    const modal = document.getElementById('edit-review-modal');
    if (!modal) {
        console.error('Edit modal not found');
        return;
    }

    modal.dataset.reviewId = reviewId;

    // Устанавливаем текущий рейтинг
    const stars = modal.querySelectorAll('.star');
    stars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= currentRating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★" style="width:24px;height:24px;">`;
        star.onclick = () => setEditRating(star, starValue);
    });

    // Сохраняем рейтинг
    modal.querySelector('.rating').dataset.rating = currentRating;

    // Устанавливаем комментарий
    modal.querySelector('#edit-comment').value = currentComment || '';

    // Показываем модальное окно
    modal.style.display = 'flex';
}

// Функция установки рейтинга при редактировании
function setEditRating(starElement, rating) {
    const starsContainer = starElement.closest('.stars');
    const stars = starsContainer.querySelectorAll('.star');

    stars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★" style="width:24px;height:24px;">`;
    });

    // Сохраняем выбранный рейтинг
    starsContainer.dataset.rating = rating;
}

function closeEditReviewModal() {
    document.getElementById('edit-review-modal').style.display = 'none';
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    // Установка текущего пользователя (должно приходить из системы авторизации)
    currentUser = 1; // Здесь должен быть ID текущего пользователя

    // Загрузка данных ресторана
    loadRestaurantData();

    // Обработчики для модального окна редактирования отзыва
    document.getElementById('edit-review-form').addEventListener('submit', function(e) {
        e.preventDefault();

        const reviewId = this.dataset.reviewId;
        const rating = this.querySelectorAll('.star.filled').length;
        const comment = this.querySelector('textarea').value;

        updateReview(reviewId, rating, comment);
        closeEditReviewModal();
    });

    // Закрытие модальных окон при клике вне их
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                if (this.id === 'review-modal') closeReviewModal();
                if (this.id === 'edit-review-modal') closeEditReviewModal();
            }
        });
    });
});
</script>
</body>
</html>