<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Городской гид - {{title}}</title>
    <!-- Подключение CSS файла -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/PersonalPage.css') }}">
    <!-- Украшаем вкладку вашим логотипом -->
    <link rel="icon" href="{{ url_for('static', filename='Фотки зданий/лого.png') }}" type="image/png">

    <script src="{{ url_for('static', filename='js/RegistrationLogin.js') }}"></script>
</head>
<script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"></script>

<body>
    <!-- Объединенная навигация -->
<nav class="navbar">
    <div class="nav-container">
        <div class="logo" onclick="window.location.href='/';">
            <img src="{{ url_for('static', filename='Фотки зданий/лого.png') }}" alt="Логотип" height="50px" width="70px">
            <span>Городской Гид</span>
        </div>

        <!-- Поиск из старого HTML с визуалом нового -->
        <form class="search-box" action="/search" method="POST">
            <input type="text" name="query" placeholder="Поиск заведений..." class="search-input" id="search-input">
            <button type="submit" class="search-button">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M21 21L16.65 16.65" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </form>

        <!-- Кнопка избранного из старого HTML -->
        <div class="favorites-wrapper">
            <div class="favorite-wrapper" id="header-favorites-btn" style="display: none;" onclick="window.location.href='/favorites'">
              <span class="particle particle-1">✦</span>
              <span class="particle particle-2">✦</span>
              <span class="particle particle-3">✦</span>
              <span class="particle particle-4">✦</span>
              <span class="particle particle-5">✦</span>
                <span class="particle particle-6">✦</span>
              <span class="particle particle-7">✦</span>
              <span class="heart-icon">❤</span>
              <span class="favorites-counter" id="favorites-count">0</span>
            </div>
        </div>

        <!-- Кнопки входа/регистрации из старого HTML с визуалом нового -->
        <div class="auth-buttons">
            <button id="loginButton" class="btn-login" onclick="showWindow()">Вход</button>
            <button id="registerButton" class="btn-register" onclick="showWindow1()">Регистрация</button>
            <div id="userInfo" style="display: none;">
                <div class="Коробка">
                    <img id="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Avatar">
                    <span id="welcomeUser"></span>
                </div>
                <button class="btn-logout" onclick="logout()">Выход</button>
            </div>
        </div>
    </div>
    <div class="clouds"></div>
</nav>

<!-- Окна входа/регистрации из старого HTML -->
<div id="overlay" style="display: none;"></div>

<div id="content_window" class="popup-window">
    <form id="loginForm" method="POST" action="/login">
        <h1>Вход</h1>
        <span class="btnX" onclick="hideWindow()">×</span>
        <div class="form-group">
            <label for="username">Логин</label>
            <input type="text" class="form-control" id="username" name="username" placeholder="Введите логин" required>
        </div>
        <div class="form-group">
            <label for="password">Пароль</label>
            <input type="password" class="form-control" id="password" name="password" placeholder="Введите пароль" required>
        </div>
        <button type="submit" class="btnA">Войти</button>
    </form>
</div>

<div id="content_window2" class="popup-window">
    <form id="regForm" method="POST" action="/register">
        <h1>Регистрация</h1>
        <span class="btnX" onclick="hideWindow1()">×</span>
        <div class="form-group">
            <label for="username1">Логин</label>
            <input type="text" id="username1" name="username" class="form-control" placeholder="Введите логин" required>
        </div>
        <div class="form-group">
            <label for="password1">Пароль</label>
            <input type="password" id="password1" name="password" class="form-control" placeholder="Введите пароль" required>
        </div>
        <div class="form-group">
            <label for="password2">Подтвердите пароль</label>
            <input type="password" id="password2" name="confirm_password" class="form-control" placeholder="Подтвердите пароль" required>
        </div>
        <div class="form-group">
            <label for="secret_key">Секретный ключ</label>
            <input type="password" id="secret_key" name="secret_key" class="form-control" placeholder="Введите секретный ключ" required>
        </div>
        <button type="submit" class="btnB">Зарегистрироваться</button>
    </form>
</div>

    <!-- Задний фон -->
    <div class="image-container">
        <img src="{{ url_for('static', filename='Фотки зданий/РесторанФон.jpg') }}" class="img-top-center" alt="РесторанФон.jpg">
    </div>
    <div class="box">
        <div class="container">
            <!-- Левая часть: картинка -->
            <div class="image-section">
                <div class="image-flip-container">
                    <!-- Передняя сторона (картинка) -->
                    <div class="image-front" >
                        <img src="{{ url_for('static', filename='Фотки зданий/Барашки.png') }}" alt="Ресторан Барашки">
                        <!-- Кнопка на карточке заведения -->
                        <button class="favorite-btn js-favorite-btn"
                                data-item-id="lambs"
                                data-item='{"id":"lambs","name":"Ресторан Lambs"}'
                                onclick="toggleFavorite('lambs', this)">
                          ❤
                        </button>
                        <!-- Кнопка развернуть в правом нижнем углу -->
                        <button class="expand-btn" onclick="expandImage(this)">↗</button>
                        <!-- Кнопка показать карту по центру снизу -->
                        <button class="map-btn" onclick="flipCard()">Показать карту</button>
                        <!-- График работы в левом верхнем углу -->
                        <div class="schedule-dropdown">
                            <button class="schedule-btn">График работы ▼</button>
                            <div class="schedule-content" id="schedule-content">
                                Пн-Пт: 10:00 - 22:00<br>
                                Сб-Вс: 11:00 - 23:00
                            </div>
                        </div>
                        <!-- Кнопка меню по центру снизу -->
                        <button class="menu-btn" onclick="openMenuModal()">Меню</button>
                    </div>

                    <!-- Задняя сторона (карта) -->
                    <div class="image-back">
                        <div class="map-container" id="map-container">
                            <h3>ул. Ломоносова, 22/2, Великий Новгород</h3>
                            <div id="yandex-map" style="width: 500px; height: 400px;">
                                <script type="text/javascript" charset="utf-8" async
                                        src="https://api-maps.yandex.ru/services/constructor/1.0/js/?um=constructor%3A5a6e03b338adf645bf44cf4d3ff45a9dae7e8cf7644abacde6f0b25ba231517d&amp;width=500&amp;height=400&amp;lang=ru_RU&amp;scroll=true">
                                </script>
                            </div>
                        </div>

                        <!-- Кнопка вернуться к изображению по центру снизу -->
                        <button class="back-btn" onclick="flipCard()">Показать изображение</button>
                    </div>
                </div>
            </div>

            <!-- Правая часть: описание -->
            <div class="details-section">
                <h1>Барашки</h1>
                <p>Ресторан «Барашки» предлагает своим гостям блюда грузинской кухни, приготовленные по традиционным рецептам.</p>
                <svg style="width: 18px; height: 18px; font-size: 17px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
                <p>+7 (8162) 55-53-22</p>
            </div>
        </div>

        <!-- Блок отзывов -->
        <div class="reviews">
            <h2>Отзывы</h2>
            <p>Общая оценка: <strong id="overall-rating">0.0</strong> (на основе <span id="total-reviews">0</span> отзывов)</p>
            <div class="rating-bars">
                <div class="rating-bar">
                    <span>5 звёзд</span>
                    <div class="bar" style="margin-left: 10px"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>4 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>3 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>2 звёзды</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
                <div class="rating-bar">
                    <span>1 звезда</span>
                    <div class="bar"><div class="fill" style="width: 0;"></div></div>
                    <span>0</span>
                </div>
            </div>

            <!-- Фильтр отзывов -->
            <div class="review-filter">
                <label>Фильтр по оценкам:</label>
                <div class="filter-controls">
                    <div class="stars" id="filter-stars">
                        <span class="star" data-value="1">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="2">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="3">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="4">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="5">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                    </div>
                    <div class="reaction-filters">
                        <span class="filter-btn" data-type="likes" title="Показать отзывы с лайками">
                            <img src="{{ url_for('static', filename='Фотки зданий/Лайк.png') }}" alt="Лайки">
                        </span>
                        <span class="filter-btn" data-type="dislikes" title="Показать отзывы с дизлайками">
                            <img src="{{ url_for('static', filename='Фотки зданий/Дизлайк.png') }}" alt="Дизлайки">
                        </span>
                    </div>
                </div>
            </div>

            <!-- Контейнер для отзывов -->
            <div class="review-container">
                <button class="scroll-button left" onclick="scrollReviews('left')">◄</button>
                <div class="review-list" id="review-list">
                    <!-- Отзывы будут добавляться сюда -->
                </div>
                <button class="scroll-button right" onclick="scrollReviews('right')">►</button>
            </div>

            <!-- Кнопка "Оставить отзыв" -->
            <button class="review-container-button" onclick="openReviewModal()">Оставить отзыв</button>
        </div>

        <!-- Модальное окно для меню -->
        <div class="modal" id="menu-modal">
            <div class="modal-content">
                <h2>Меню</h2>
                <p>Здесь будет содержимое меню.</p>
                <button onclick="closeMenuModal()">Закрыть</button>
            </div>
        </div>

        <!-- Модальное окно для отзыва -->
        <div class="modal" id="review-modal">
            <div class="modal-content">
                <span class="close" onclick="closeReviewModal()">&times;</span>
                <h2>Оставить отзыв</h2>
                <form id="review-form">
                    <label class="review-form-name" for="name">Имя:</label>
                    <input type="text" id="name" required><br><br>
                    <label>Оценка: <span id="rating-error" style="color: red; display: none; font-size: 11px">*Обязательное поле</span></label>
                    <div class="stars" id="review-stars">
                        <span class="star" data-value="1">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="2">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="3">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="4">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="5">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                    </div><br>
                    <label for="comment">Комментарий:</label><br>
                    <textarea id="comment" rows="4"></textarea><br><br>
                    <button class="review-form-button" type="submit">Отправить</button>
                </form>
            </div>
        </div>

        <!-- Модальное окно для развёрнутого отзыва -->
        <div class="modal" id="full-review-modal">
            <div class="modal-content">
                <span class="close" onclick="closeFullReviewModal()">&times;</span>
                <h2>Полный отзыв</h2>
                <div class="review-header">
                    <img class="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Аватар">
                    <div class="name-rating-modal">
                        <div class="review-name"></div>
                        <div class="review-rating"></div>
                    </div>
                </div>
                <div class="review-comment"></div>
                <div class="review-actions">
                    <button class="like-btn" onclick="likeReview()">
                        <img src="{{ url_for('static', filename='Фотки зданий/Лайк.png') }}" alt="Лайк">
                        <span class="like-count">0</span>
                    </button>
                    <button class="dislike-btn" onclick="dislikeReview()">
                        <img src="{{ url_for('static', filename='Фотки зданий/Дизлайк.png') }}" alt="Дизлайк">
                        <span class="dislike-count">0</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно для редактирования отзыва -->
    <div class="modal" id="edit-review-modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h2>Редактировать отзыв</h2>
            <form id="edit-review-form">
                <input type="hidden" id="edit-review-id">
                <input type="hidden" id="edit-user-token" value="">

                <div class="form-group">
                    <label>Оценка:</label>
                    <div class="stars" id="edit-stars">
                        <span class="star" data-value="1" onclick="setEditRating(1)">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="2" onclick="setEditRating(2)">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="3" onclick="setEditRating(3)">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="4" onclick="setEditRating(4)">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                        <span class="star" data-value="5" onclick="setEditRating(5)">
                            <img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">
                        </span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="edit-comment">Комментарий:</label>
                    <textarea id="edit-comment" rows="4" required></textarea>
                </div>

                <div class="form-buttons">
                    <button type="button" class="btn-cancel" onclick="closeEditModal()">Отмена</button>
                    <button type="submit" class="btn-save">Сохранить изменения</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Городской силуэт перед футером -->
    <div class="skyscrapers"></div>

    <!-- Футер -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section about">
                <img src="{{ url_for('static', filename='Фотки зданий/лого.png') }}" style="width: 120px;" alt="Логотип">
                <p>Городской гид - ваш путеводитель по лучшим местам Великого Новгорода</p>
                <div class="socials">
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/TG.png') }}" alt="Telegram"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/YT.png') }}" style="margin-bottom: 0; margin-top: 8px" alt="YouTube"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/vk.png') }}" alt="VK"></a>
                    <a href="#"><img src="{{ url_for('static', filename='Фотки зданий/OK.png') }}" alt="OK"></a>
                </div>
            </div>

            <div class="footer-section links">
                <h3>Навигация</h3>
                <ul>
                    <li><a href="#">Главная</a></li>
                    <li><a href="#">О проекте</a></li>
                    <li><a href="#">Контакты</a></li>
                    <li><a href="#">Помощь</a></li>
                </ul>
            </div>

            <div class="footer-section contact">
                <h3>Контакты</h3>
                <p><i class="phone-icon"></i> +7 (123) 456-78-90</p>
                <p><i class="email-icon"></i> info@gorodskoygid.ru</p>
                <p><i class="location-icon"></i> Великий Новгород</p>
            </div>
        </div>

        <div class="footer-bottom">
            &copy; 2025 Городской Гид | Все права защищены
        </div>
    </footer>
    <script>
        // Константы
// Константы
const PATHS = {
    starActive: "/static/Фотки зданий/baka.png",
    starInactive: "/static/Фотки зданий/star.png",
    avatar: "/static/Фотки зданий/avatar.png",
    like: "/static/Фотки зданий/Лайк.png",
    dislike: "/static/Фотки зданий/Дизлайк.png"
};

// Массив для хранения отзывов
    let reviews = [];
    // Переменная для хранения текущего рейтинга при редактировании
let editRating = 0;

// Глобальные переменные
const currentRestaurantId = 'lambs';
let selectedRating = 0;
let lastReviewTime = localStorage.getItem('lastReviewTime') || 0;
// Глобальные переменные для управления лайками/дизлайками
let currentReviewId = null;
let currentUserRating = null;
// Глобальные переменные для отслеживания состояния
let pageReloaded = false;
let reviewCreationInProgress = false;

// Генерируем токен СРАЗУ при загрузке скрипта
let userToken = localStorage.getItem('userToken') || generateUserToken();

let currentFilters = {
    rating: 0,
    reaction: 'none'
};

document.addEventListener('DOMContentLoaded', function() {
    trackPageReload(); // Отслеживаем перезагрузку
    updateFavoritesCount(); // Проверка избранного при загрузке
    initStats(); // Загрузка статистики и отзывов Вместо updateOverallRating()
    initFilters(); // Инициализация фильтров - ДОБАВЬТЕ ЭТУ СТРОЧКУ!
    loadReviews(); // Загрузка отзывов
    setInterval(saveRatingsToStorage, 30000); // Периодическое сохранение (каждые 30 секунд)

    document.getElementById('full-review-modal').style.display = 'none';

    // Генерируем/восстанавливаем токен
    userToken = localStorage.getItem('userToken') || generateUserToken();
    console.log('User token при загрузке:', userToken);

    // Сохраняем токен в localStorage
    localStorage.setItem('userToken', userToken);

    // Обработчик скролла
    const reviewList = document.getElementById('review-list');
    if (reviewList) {
        reviewList.addEventListener('scroll', updateScrollButtons);
    }

    // Генерируем токен
    userToken = generateUserToken();
    console.log('User token:', userToken);


    // Обработчики для кнопок в карточках
    document.querySelectorAll('.js-favorite-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const itemId = this.dataset.itemId;
      const itemData = JSON.parse(this.dataset.item);
      toggleFavorite(itemId, itemData);
    });
    });

    // Синхронизация между вкладками
    window.addEventListener('storage', function(event) {
    if (event.key === 'favorites') {
      updateFavoritesCount();
    }
    });

    // Инициализация кнопки
    const headerFavBtn = document.getElementById('header-favorites-btn');
    const particles = headerFavBtn.querySelectorAll('.particle');

    // Анимация частиц
    headerFavBtn.addEventListener('mouseenter', function() {
    this.classList.add('active');
    });

    headerFavBtn.addEventListener('mouseleave', function() {
    this.classList.remove('active');
    });

    // Обработчик для кнопки закрытия
    const closeBtn = document.querySelector('#review-modal .close');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeReviewModal);
    }

    // УБЕРИТЕ все другие обработчики для review-form и оставьте только этот:
    const reviewForm = document.getElementById('review-form');
    if (reviewForm) {
        // Удаляем все предыдущие обработчики
        reviewForm.onsubmit = null;
        reviewForm.addEventListener('submit', function(e) {
            submitReview(e);
        });
    }

    // Обработчик клика вне модального окна
    const modal = document.getElementById('review-modal');
    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                closeReviewModal();
            }
        });
    }

    const editForm = document.getElementById('edit-review-form');
    if (editForm) {
        editForm.addEventListener('submit', function(e) {
            submitEditReview(e);
        });
    }

    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));

            // Обновляем отображение звезд
            stars.forEach((s, index) => {
                const starValue = parseInt(s.getAttribute('data-value'));
                const starImage = starValue <= selectedRating ? PATHS.starActive : PATHS.starInactive;
                s.innerHTML = `<img src="${starImage}" alt="★">`;
            });

            document.getElementById('rating-error').style.display = 'none';
        });
    });


    setTimeout(() => {updateScrollButtons();}, 500);
    setTimeout(updateScrollButtons, 1000); // Проверяем кнопки после полной загрузки страницы

    setTimeout(() => {
        updateScrollButtons();
        // Дополнительная проверка через секунду
        setTimeout(updateScrollButtons, 1000);
    }, 500);

    // Автоматическая миграция при загрузке
    setTimeout(() => {
        migrateLegacyReviews().then(success => {
            if (success) {
                // Перезагружаем отзывы после миграции
                loadReviews();
            }
        });
    }, 2000);

    // Остальная инициализация...
});

// Новая функция для инициализации кнопок скролла
function initScrollButtons() {
    const reviewList = document.getElementById('review-list');
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!reviewList || !leftButton || !rightButton) {
        console.log('Scroll elements not found during init');
        return;
    }

    // Принудительно показываем кнопки для проверки
    leftButton.style.display = 'block';
    rightButton.style.display = 'block';

    // Проверяем контент после небольшой задержки
    setTimeout(() => {
        const hasContent = reviewList.children.length > 0;
        const canScroll = reviewList.scrollWidth > reviewList.clientWidth;

        console.log('Init scroll check:', {
            children: reviewList.children.length,
            scrollWidth: reviewList.scrollWidth,
            clientWidth: reviewList.clientWidth,
            canScroll: canScroll
        });

        if (hasContent && canScroll) {
            leftButton.style.display = 'block';
            rightButton.style.display = 'block';
            updateScrollButtons();
        } else {
            leftButton.style.display = 'none';
            rightButton.style.display = 'none';
        }
    }, 100);
}

// Улучшенная генерация токена
function generateUserToken() {
    let token = localStorage.getItem('userToken');

    if (!token) {
        const deviceId = getDeviceFingerprint();
        const randomPart = Math.random().toString(36).substr(2, 8);
        const timestamp = Date.now().toString(36);
        token = `token-${deviceId}-${randomPart}-${timestamp}`;
        localStorage.setItem('userToken', token);
        console.log('🆕 Сгенерирован новый user token:', token);
    } else {
        console.log('🔄 Восстановлен существующий user token:', token);
    }

    return token;
}

function validateReviewForm() {
    const name = document.getElementById('name').value.trim();
    const rating = selectedRating;

    if (!name) {
        document.getElementById('name').style.borderColor = '#ff4444';
        return false;
    }

    if (rating === 0) {
        document.getElementById('rating-error').style.display = 'inline';
        return false;
    }

    return true;
}

// Временная функция для принудительного показа кнопок (для отладки)
function forceShowEditButtons() {
    const modal = document.getElementById('full-review-modal');
    if (!modal) return;

    const reviewId = modal.dataset.reviewId;
    const review = reviews.find(r => r.id == reviewId);
    if (!review) return;

    // Принудительно устанавливаем права
    review.user_token = userToken;
    review.device_fingerprint = getDeviceFingerprint();

    // Перезагружаем кнопки
    addEditDeleteButtonsToModal(modal, review);
    console.log('Кнопки принудительно показаны');
}

// Функция для отслеживания перезагрузки
function trackPageReload() {
    // Проверяем, была ли страница перезагружена
    if (performance.navigation.type === 1 || performance.getEntriesByType("navigation")[0]?.type === 'reload') {
        console.log('🔄 Страница была перезагружена');
        pageReloaded = true;

        // Восстанавливаем userToken после перезагрузки
        userToken = localStorage.getItem('userToken') || generateUserToken();
        console.log('🔄 UserToken после перезагрузки:', userToken);
    }
}

// Улучшенная функция создания отзыва с защитой от перезагрузки
async function submitReview(e) {
    if (e) e.preventDefault();

    console.log('=== ОТПРАВКА ОТЗЫВА ===');

    const name = document.getElementById('name').value.trim();
    const comment = document.getElementById('comment').value.trim();
    const deviceFingerprint = getDeviceFingerprint();

    // Валидация формы
    if (!name) {
        document.getElementById('name').style.borderColor = '#ff4444';
        return false;
    }

    if (selectedRating === 0) {
        document.getElementById('rating-error').style.display = 'inline';
        return false;
    }

    // console.log('Данные формы:');
    // console.log('  Имя:', name);
    // console.log('  Комментарий:', comment);
    // console.log('  Рейтинг:', selectedRating);
    // console.log('  User token:', userToken);
    // console.log('  Device fingerprint:', deviceFingerprint);
    // console.log('Отправляемые данные:', payload);
    // console.log('Полный ответ сервера:', data);

    // Блокируем повторные отправки
    reviewCreationInProgress = true;
    const submitButton = document.querySelector('#review-form button[type="submit"]');
    const originalText = submitButton.textContent;
    submitButton.textContent = 'Отправка...';
    submitButton.disabled = true;

    try {
        const payload = {
            restaurant_id: currentRestaurantId,
            username: name,
            rating: selectedRating,
            comment: comment,
            user_token: userToken,
            device_fingerprint: deviceFingerprint
        };

        console.log('Отправляемые данные:', payload);

        const response = await fetch('/api/reviews', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });

        const data = await response.json();
        console.log('Полный ответ сервера:', data);

        if (response.ok) {
            if (data.review) {
                reviews.unshift(data.review);
                addReviewToUIImmediately(data.review);

                // ВАЖНО: Принудительно обновляем порядок после добавления
                setTimeout(() => {
                    refreshReviewsOrder();
                    applyFilters(); // Переприменяем фильтры
                }, 200);

                // Добавляем в глобальный массив
                reviews.unshift(data.review);
                // console.log('Отзыв добавлен в глобальный массив с user_token:', data.review.user_token);
            }

            // НЕМЕДЛЕННО добавляем отзыв в UI
            addReviewToUIImmediately(data.review);

            // Закрываем модальное окно
            closeReviewModal();

            // Сбрасываем форму
            resetReviewForm();

            // Обновляем статистику
            setTimeout(() => {
                initStats();
            }, 500);

        } else {
            throw new Error(data.error || 'Ошибка при добавлении отзыва');
        }

    } catch (error) {
        console.error('Ошибка:', error);
    } finally {
        // Разблокируем кнопку
        reviewCreationInProgress = false;
        if (submitButton) {
            submitButton.textContent = originalText;
            submitButton.disabled = false;
        }
    }

    return false;
}

// Функции для индикатора загрузки
function showLoadingIndicator() {
    let loader = document.getElementById('loading-indicator');
    if (!loader) {
        loader = document.createElement('div');
        loader.id = 'loading-indicator';
        loader.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
        `;
        loader.innerHTML = 'Отправка...';
        document.body.appendChild(loader);
    }
    loader.style.display = 'block';
}

function hideLoadingIndicator() {
    const loader = document.getElementById('loading-indicator');
    if (loader) {
        loader.style.display = 'none';
    }
}

// Улучшенная функция добавления отзыва в UI
function addReviewToUIImmediately(review) {
    console.log('=== ДОБАВЛЕНИЕ ОТЗЫВА В UI ===');

    const reviewList = document.getElementById('review-list');
    if (!reviewList) {
        console.error('Review list not found');
        return;
    }

    // Убираем сообщение "Нет отзывов"
    const noReviewsMsg = reviewList.querySelector('.no-reviews');
    if (noReviewsMsg) {
        noReviewsMsg.remove();
    }

    // ВАЖНО: Добавляем отзыв в глобальный массив ПЕРВЫМ
    const existingIndex = reviews.findIndex(r => r.id === review.id);
    if (existingIndex === -1) {
        reviews.unshift(review); // Добавляем в начало массива
    } else {
        reviews[existingIndex] = review;
    }

    // Создаем элемент отзыва
    const reviewElement = createReviewElement(review);

    // Устанавливаем data-атрибуты для фильтрации
    reviewElement.dataset.reviewId = review.id;
    reviewElement.dataset.rating = review.rating;
    reviewElement.dataset.likes = review.likes || 0;
    reviewElement.dataset.dislikes = review.dislikes || 0;

    // ВАЖНО: Добавляем в DOM в начало (но после применения фильтров)
    if (reviewList.firstChild) {
        reviewList.insertBefore(reviewElement, reviewList.firstChild);
    } else {
        reviewList.appendChild(reviewElement);
    }

    // ПРИМЕНЯЕМ ТЕКУЩИЕ ФИЛЬТРЫ К НОВОМУ ОТЗЫВУ
    applyFiltersToSingleReview(reviewElement, review);

    // Анимация появления
    reviewElement.style.opacity = '0';
    reviewElement.style.transform = 'translateY(-20px)';

    setTimeout(() => {
        reviewElement.style.transition = 'all 0.3s ease';
        reviewElement.style.opacity = '1';
        reviewElement.style.transform = 'translateY(0)';
    }, 10);

    // Обновляем скролл-кнопки
    setTimeout(updateScrollButtons, 100);
}

// НОВАЯ функция для применения фильтров к одному отзыву
function applyFiltersToSingleReview(reviewElement, review) {
    if (!reviewElement || !review) return;

    const cardRating = review.rating;
    const likes = parseInt(review.likes || 0);
    const dislikes = parseInt(review.dislikes || 0);

    const matchesRating = currentFilters.rating === 0 || cardRating === currentFilters.rating;
    const matchesReaction = checkReactionMatch(likes, dislikes);

    if (matchesRating && matchesReaction) {
        reviewElement.style.display = 'flex';
        console.log(`Review ${review.id} matches filters - showing`);
    } else {
        reviewElement.style.display = 'none';
        console.log(`Review ${review.id} doesn't match filters - hiding`);
    }
}

// Новая функция для применения фильтров к новому отзыву
function applyFiltersToNewReview(reviewElement, review) {
    const cardRating = review.rating;
    const likes = parseInt(review.likes || 0);
    const dislikes = parseInt(review.dislikes || 0);

    const matchesRating = currentFilters.rating === 0 || cardRating === currentFilters.rating;
    const matchesReaction = checkReactionMatch(likes, dislikes);

    if (matchesRating && matchesReaction) {
        reviewElement.style.display = 'flex';
    } else {
        reviewElement.style.display = 'none';
    }
}

// Обновленная функция отображения отзывов
function displayReviews(reviewsData) {
    const reviewList = document.getElementById('review-list');
    if (!reviewList) return;

    reviewList.innerHTML = '';
    reviews = reviewsData || [];

    if (!reviewsData || reviewsData.length === 0) {
        reviewList.innerHTML = '<div class="no-reviews">Пока нет отзывов. Будьте первым!</div>';
        updateScrollButtons();
        return;
    }

    // ВАЖНО: Добавляем отзывы в правильном порядке (новые сверху)
    reviewsData.forEach(review => {
        const reviewElement = createReviewElement(review);
        reviewList.appendChild(reviewElement);
    });

    // Обновляем скролл
    setTimeout(updateScrollButtons, 100);
}

// Обновление статистики
function updateRatingStats(stats) {
    document.getElementById('overall-rating').textContent = stats.average_rating.toFixed(1);
    document.getElementById('total-reviews').textContent = stats.total_reviews;

    // Обновляем шкалы рейтинга
    for (let i = 1; i <= 5; i++) {
        const count = stats.ratings[i] || 0;
        const percentage = stats.total_reviews > 0 ? (count / stats.total_reviews) * 100 : 0;
        const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
        const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);

        if (bar) bar.style.width = `${percentage}%`;
        if (countSpan) countSpan.textContent = count;
    }
}

// Обновленный UI для отзывов с возможностью редактирования
function updateReviewsUI(reviews) {
    const reviewList = document.getElementById('review-list');
    reviewList.innerHTML = '';

    if (!reviews || reviews.length === 0) {
        reviewList.innerHTML = '<div class="no-reviews">Пока нет отзывов. Будьте первым!</div>';
        return;
    }

    reviews.forEach(review => {
        const canEdit = checkEditPermission(review);
        const reviewElement = createReviewElement(review, canEdit);
        reviewList.appendChild(reviewElement);
    });

    updateReviewVisibility();
}

function createReviewElement(review) {
    const reviewElement = document.createElement('div');
    reviewElement.className = 'review-card';
    reviewElement.dataset.reviewId = review.id || Date.now();
    reviewElement.dataset.rating = review.rating;
    reviewElement.dataset.likes = review.likes || 0;  // ✅ Сохраняем лайки
    reviewElement.dataset.dislikes = review.dislikes || 0;  // ✅ Сохраняем дизлайки

    // Экранируем кавычки для безопасности
    const safeComment = review.comment ? review.comment.replace(/'/g, "&#39;").replace(/"/g, "&quot;") : '';
    const safeUsername = review.username ? review.username.replace(/'/g, "&#39;").replace(/"/g, "&quot;") : '';

    // Форматируем дату
    const reviewDate = review.created_at ?
        formatDate(review.created_at) :
        'Только что';

    // Создаем HTML для звезд рейтинга
    let starsHTML = '';
    for (let i = 0; i < 5; i++) {
        if (i < review.rating) {
            starsHTML += `<img src="${PATHS.starActive}" alt="★" style="width:20px;height:20px;">`;
        } else {
            starsHTML += `<img src="${PATHS.starInactive}" alt="★" style="width:20px;height:20px;">`;
        }
    }

    reviewElement.innerHTML = `
        <div class="review-header">
            <div class="date-avatar">
                <img class="avatar" src="${PATHS.avatar}" alt="Аватар">
                <div class="review-date-small">${reviewDate}</div>
            </div>
            <div class="name-rating">
                <div class="name">${safeUsername}</div>
                <div class="review-rating">
                    ${starsHTML}
                </div>
            </div>
        </div>
        <div class="comment-container">
            <div class="comment-text">${review.comment || ''}</div>
            ${review.comment ? '<div class="comment-blur"></div>' : ''}
        </div>
        ${review.comment ? `
            <div class="review-actions-bottom">
                <button class="expand-text-link" onclick="openFullReviewModal(${review.id || Date.now()})">
                    Развернуть
                </button>
            </div>
        ` : ''}
    `;

    return reviewElement;
}

// Улучшенная функция проверки прав на редактирование
async function checkEditPermission(review) {
    try {
        // Проверяем по токену пользователя - ТОЛЬКО владелец может редактировать
        if (review.user_token !== userToken) {
            console.log('Edit denied: different user token');
            return false;
        }

        // Проверяем по отпечатку устройства
        if (!isSameDevice(review)) {
            console.log('Edit denied: different device');
            return false;
        }

        // Проверяем время (3 часа)
        const createdAt = new Date(review.created_at);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

        if (hoursDiff > 3) {
            console.log('Edit denied: time expired', hoursDiff);
            return false;
        }

        console.log('Edit allowed');
        return true;
    } catch (error) {
        console.error('Error checking edit permission:', error);
        return false;
    }
}

// Улучшенная функция проверки того же устройства
function isSameDevice(review) {
    try {
        // Получаем fingerprint текущего устройства
        const currentFingerprint = getDeviceFingerprint();

        // Создаем резервный fingerprint на основе userAgent и других параметров
        const backupFingerprint = btoa(navigator.userAgent + navigator.language + screen.width);

        // Проверяем оба варианта
        const isSame = review.device_fingerprint === currentFingerprint ||
                      review.device_fingerprint === backupFingerprint;

        console.log('Device check:', {
            stored: review.device_fingerprint,
            current: currentFingerprint,
            backup: backupFingerprint,
            isSame: isSame
        });

        return isSame;
    } catch (error) {
        console.error('Error checking device:', error);
        return false;
    }
}

// Улучшенная генерация отпечатка устройства
function getDeviceFingerprint() {
    const components = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        new Date().getTimezoneOffset(),
        navigator.hardwareConcurrency || 'unknown'
    ];

    // Создаем стабильный хэш
    return btoa(components.join('|')).substring(0, 32);
}

// Форматирование даты
function formatDate(dateString) {
    if (!dateString) return '<div>Только что</div><div></div>';

    try {
        const date = new Date(dateString);
        const formattedDate = date.toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'numeric',
            year: 'numeric'
        });
        const formattedTime = date.toLocaleTimeString('ru-RU', {
            hour: '2-digit',
            minute: '2-digit'
        });

        return `<div>${formattedDate}</div><div>${formattedTime}</div>`;
    } catch (e) {
        return '<div>Только что</div><div></div>';
    }
}

// Модальное окно для редактирования
function openEditModal(reviewId, currentRating, currentComment) {
    const modal = document.getElementById('edit-modal');
    modal.dataset.reviewId = reviewId;

    // Установка текущего рейтинга
    const stars = modal.querySelectorAll('.star');
    stars.forEach((star, index) => {
        star.innerHTML = `<img src="${index < currentRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
    });

    // Установка комментария
    modal.querySelector('#edit-comment').value = currentComment || '';

    // Показываем модальное окно
    modal.style.display = 'flex';
}

// УСИЛЕННАЯ функция удаления отзыва
async function deleteReview(reviewId) {
    try {
        console.log(`=== ПОПЫТКА УДАЛЕНИЯ ОТЗЫВА ${reviewId} ===`);

        const review = reviews.find(r => r.id == reviewId);
        if (!review) {
            return;
        }

        // ДВОЙНАЯ ПРОВЕРКА: Убеждаемся что пользователь автор
        if (!checkIsAuthor(review)) {
            console.log('Permission denied: user is not author');
            return;
        }

        const response = await fetch(`/api/reviews/${reviewId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                user_token: userToken,
                device_fingerprint: getDeviceFingerprint()
            })
        });

        const data = await response.json();
        console.log('Ответ сервера:', data);

        if (response.ok) {

            // Закрываем модальные окна
            closeFullReviewModal();
            const confirmModal = document.getElementById('delete-confirmation-modal');
            if (confirmModal) {
                document.body.removeChild(confirmModal);
            }

            // Перезагружаем отзывы и статистику
            setTimeout(() => {
                loadReviews();
                initStats();
            }, 500);
        } else {
            throw new Error(data.error || 'Ошибка при удалении');
        }
    } catch (error) {
        console.error('Error deleting review:', error);
    }
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    loadReviews();
    updateOverallRating();

    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));
            stars.forEach((s, index) => {
                s.innerHTML = `<img src="${index < selectedRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
            });
        });
    });
});

// Улучшенная функция генерации токена
function generateEnhancedUserToken() {
    // Собираем информацию о браузере (анонимно)
    const browserInfo = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${screen.width}x${screen.height}`
    };

    // Создаем хэш на основе информации
    const browserHash = btoa(JSON.stringify(browserInfo)).substr(0, 12);

    const token = `token-${browserHash}-${Math.random().toString(36).substr(2, 6)}-${Date.now().toString(36)}`;

    localStorage.setItem('userToken', token);
    return token;
}

















// Инициализация фильтров
function initFilters() {
    // Обработчики для звезд
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.addEventListener('click', function() {
            const value = parseInt(this.getAttribute('data-value'));

            // Если кликаем на уже выбранную звезду - сбрасываем
            if (currentFilters.rating === value) {
                currentFilters.rating = 0;
                resetStarFilter();
            } else {
                currentFilters.rating = value;
                highlightStars(value);
            }

            applyFilters();
        });
    });

    // Обработчики для кнопок реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const filterType = this.getAttribute('data-type');

            // Если кликаем на уже активную кнопку - сбрасываем
            if (currentFilters.reaction === filterType) {
                currentFilters.reaction = 'none';
                resetReactionFilter();
            } else {
                currentFilters.reaction = filterType;
                highlightReactionButton(filterType);
            }

            applyFilters();
        });
    });

    resetScroll();
}

// Функция для сброса всех фильтров
function resetAllFilters() {
    currentFilters = {
        rating: 0,
        reaction: 'none'
    };

    // Сбрасываем звезды
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });

    // Сбрасываем кнопки реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
    });

    // Применяем фильтры (покажет все отзывы)
    applyFilters();

    // Сбрасываем скролл
    resetScroll();
}

function updateFilterButtons() {
    // Обновляем кнопки реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === currentFilters.reaction) {
            btn.classList.add('active');
        }
    });

    // Обновляем звезды фильтра
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= currentFilters.rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★">`;
    });
}

// ОБНОВЛЕННАЯ функция применения фильтров
function applyFilters() {
    const reviewList = document.getElementById('review-list');
    if (!reviewList) return;

    // Удаляем старое сообщение "Нет отзывов"
    const oldMsg = document.getElementById('no-reviews-message');
    if (oldMsg) oldMsg.remove();

    let hasMatches = false;

    // ВАЖНО: Получаем ВСЕ отзывы из DOM (не только видимые)
    const allReviewCards = Array.from(reviewList.querySelectorAll('.review-card'));

    // ВАЖНО: Сортируем отзывы в том же порядке, что и в массиве reviews
    allReviewCards.sort((a, b) => {
        const aId = parseInt(a.dataset.reviewId);
        const bId = parseInt(b.dataset.reviewId);
        const aIndex = reviews.findIndex(r => r.id === aId);
        const bIndex = reviews.findIndex(r => r.id === bId);
        return aIndex - bIndex; // Сохраняем исходный порядок
    });

    // Переставляем отзывы в правильном порядке
    allReviewCards.forEach(card => {
        reviewList.appendChild(card);
    });

    // Теперь применяем фильтры
    allReviewCards.forEach(card => {
        const reviewId = card.dataset.reviewId;
        const review = reviews.find(r => r.id == reviewId);

        if (review) {
            const cardRating = review.rating;
            const likes = parseInt(review.likes || 0);
            const dislikes = parseInt(review.dislikes || 0);

            const matchesRating = currentFilters.rating === 0 || cardRating === currentFilters.rating;
            const matchesReaction = checkReactionMatch(likes, dislikes);

            if (matchesRating && matchesReaction) {
                card.style.display = 'flex';
                hasMatches = true;
            } else {
                card.style.display = 'none';
            }
        }
    });

    // Показываем сообщение если нет совпадений
    if (!hasMatches) {
        showNoReviewsMessage();
    }

    // ВАЖНО: При фильтрации по реакциям дополнительно сортируем
    if (currentFilters.reaction !== 'none' && hasMatches) {
        sortReviewsByReaction();
    }

    // Обновляем скролл после фильтрации
    setTimeout(updateScrollButtons, 150);
}

function resetScroll() {
    const reviewList = document.getElementById('review-list');
    if (reviewList) {
        reviewList.scrollLeft = 0;
        setTimeout(updateScrollButtons, 150);
    }
}

// Проверка соответствия фильтру реакций
function checkReactionMatch(likes, dislikes) {
    switch (currentFilters.reaction) {
        case 'likes':
            return likes > 0;
        case 'dislikes':
            return dislikes > 0;
        case 'none':
        default:
            return true;
    }
}

// Подсветка звезд фильтра
function highlightStars(rating) {
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★">`;
    });
}

// Подсветка кнопки реакции
function highlightReactionButton(filterType) {
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === filterType) {
            btn.classList.add('active');
        }
    });
}

// Сброс фильтра звезд
function resetStarFilter() {
    const filterStars = document.querySelectorAll('#filter-stars .star');
    filterStars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });
}

// Сброс фильтра реакций
function resetReactionFilter() {
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-type') === 'none') {
            btn.classList.add('active');
        }
    });
}

// Функция сортировки отзывов
function sortReviews(reviewsArray) {
    if (currentFilter.reaction === 'likes') {
        reviewsArray.sort((a, b) => b.likes - a.likes);
    } else if (currentFilter.reaction === 'dislikes') {
        reviewsArray.sort((a, b) => b.dislikes - a.dislikes);
    }
}

// Сообщение об отсутствии отзывов
function showNoReviewsMessage() {
    const reviewList = document.getElementById('review-list');

    // Убедимся, что сообщение еще не отображается
    if (reviewList.querySelector('#no-reviews-message')) {
        return;
    }

    const msg = document.createElement('div');
    msg.id = 'no-reviews-message';

    let messageText = 'Отзывов нет';
    if (currentFilters.rating !== 0) {
        messageText += ` с ${currentFilters.rating} звездами`;
    }
    if (currentFilters.reaction !== 'none') {
        messageText += currentFilters.rating !== 0 ? ' и' : ' с';
        messageText += currentFilters.reaction === 'likes' ? ' лайками' : ' дизлайками';
    }

    msg.textContent = messageText + '!';
    msg.style.textAlign = 'center';
    msg.style.padding = '20px';
    msg.style.color = '#666';
    msg.style.width = '100%';

    // Добавляем сообщение, но НЕ очищаем весь список!
    reviewList.appendChild(msg);

    // Обновляем кнопки скролла
    updateScrollButtons();
}

// Функция сброса противоположного фильтра
function resetOppositeFilter() {
    // При изменении звезд сбрасываем реакции
    if (currentFilter.rating !== 0 && currentFilter.reaction !== 'none') {
        currentFilter.reaction = 'none';
        const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
        filterButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-type') === 'none') {
                btn.classList.add('active');
            }
        });
    }

    // При изменении реакций сбрасываем звезды
    if (currentFilter.reaction !== 'none' && currentFilter.rating !== 0) {
        currentFilter.rating = 0;
        const filterStars = document.querySelectorAll('#filter-stars .star');
        filterStars.forEach(star => {
            star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
        });
    }
}

// Улучшенная функция сортировки по реакциям
function sortReviewsByReaction() {
    const reviewList = document.getElementById('review-list');
    const visibleReviews = Array.from(reviewList.querySelectorAll('.review-card'))
        .filter(card => card.style.display !== 'none');

    // Сортируем только видимые отзывы
    visibleReviews.sort((a, b) => {
        const aLikes = parseInt(a.dataset.likes || 0);
        const bLikes = parseInt(b.dataset.likes || 0);
        const aDislikes = parseInt(a.dataset.dislikes || 0);
        const bDislikes = parseInt(b.dataset.dislikes || 0);

        if (currentFilters.reaction === 'likes') {
            return bLikes - aLikes; // По убыванию лайков
        } else if (currentFilters.reaction === 'dislikes') {
            return bDislikes - aDislikes; // По убыванию дизлайков
        }
        return 0;
    });

    // Переставляем отзывы в правильном порядке
    visibleReviews.forEach(review => {
        reviewList.appendChild(review);
    });
}

// Функция для обновления порядка отзывов согласно массиву reviews
function refreshReviewsOrder() {
    const reviewList = document.getElementById('review-list');
    if (!reviewList) return;

    // Получаем все карточки отзывов
    const allCards = Array.from(reviewList.querySelectorAll('.review-card'));

    // Сортируем карточки в том же порядке, что и в массиве reviews
    allCards.sort((a, b) => {
        const aId = parseInt(a.dataset.reviewId);
        const bId = parseInt(b.dataset.reviewId);
        const aIndex = reviews.findIndex(r => r.id === aId);
        const bIndex = reviews.findIndex(r => r.id === bId);
        return aIndex - bIndex;
    });

    // Переставляем карточки в правильном порядке
    allCards.forEach(card => {
        reviewList.appendChild(card);
    });

    // Обновляем скролл
    setTimeout(updateScrollButtons, 100);
}



// ===== КОНФИГУРАЦИЯ =====
const STORAGE_KEY = 'restaurant_reviews_ratings';

// ===== ОСНОВНЫЕ ФУНКЦИИ =====

// Функция для сохранения оценок в LocalStorage
function saveRatingsToStorage() {
    const ratingsData = {
        version: '2.0', // Обновили версию
        timestamp: new Date().toISOString(),
        ratings: reviews.reduce((acc, review) => {
            if (review.id) {
                acc[review.id] = {
                    likes: review.likes || 0,
                    dislikes: review.dislikes || 0,
                    user_ratings: review.user_ratings || {} // Храним оценки пользователей
                };
            }
            return acc;
        }, {})
    };

    localStorage.setItem(STORAGE_KEY, JSON.stringify(ratingsData));
    console.log('Ratings saved to localStorage');
}

// Функция для загрузки оценок из LocalStorage
function loadRatingsFromStorage() {
    try {
        const storedData = localStorage.getItem(STORAGE_KEY);
        if (!storedData) return {};

        const data = JSON.parse(storedData);

        // Проверяем версию
        if (data.version === '2.0') {
            return data.ratings || {};
        }
    } catch (error) {
        console.error('Error loading ratings from storage:', error);
    }
    return {};
}

// Функция для применения сохраненных оценок
function applyStoredRatings() {
    const storedRatings = loadRatingsFromStorage();

    reviews.forEach(review => {
        if (review.id && storedRatings[review.id]) {
            const stored = storedRatings[review.id];
            review.likes = stored.likes;
            review.dislikes = stored.dislikes;
            review.user_ratings = stored.user_ratings || {};
        }
    });

    console.log('Stored ratings applied');
}

// Функция обновления UI
function updateReviewUI(reviewId, likes, dislikes, userRating) {
    // Обновляем модальное окно
    const modal = document.getElementById('full-review-modal');
    if (modal && modal.dataset.reviewId == reviewId) {
        updateModalRatingUI(likes, dislikes, userRating);
    }

    // Обновляем карточку отзыва в списке
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        reviewElement.dataset.likes = likes || 0;
        reviewElement.dataset.dislikes = dislikes || 0;
    }
}

// Функция обновления UI в модальном окне
function updateModalRatingUI(likes, dislikes, userRating) {
    const likeCountElem = document.querySelector('#full-review-modal .like-count');
    const dislikeCountElem = document.querySelector('#full-review-modal .dislike-count');
    const likeBtn = document.querySelector('#full-review-modal .like-btn');
    const dislikeBtn = document.querySelector('#full-review-modal .dislike-btn');

    if (likeCountElem) likeCountElem.textContent = likes || 0;
    if (dislikeCountElem) dislikeCountElem.textContent = dislikes || 0;

    // Сбрасываем все активные состояния
    if (likeBtn) likeBtn.classList.remove('active');
    if (dislikeBtn) dislikeBtn.classList.remove('active');

    // Устанавливаем активное состояние
    if (userRating === 'like' && likeBtn) {
        likeBtn.classList.add('active');
    } else if (userRating === 'dislike' && dislikeBtn) {
        dislikeBtn.classList.add('active');
    }

    console.log('UI обновлен:', { likes, dislikes, userRating });
}

// ===== ОБНОВЛЕННАЯ ФУНКЦИЯ rateReview =====
// Основная функция оценки отзыва
async function rateReview(isLike, reviewId) {
    try {
        console.log(`=== ОЦЕНКА ОТЗЫВА ===`);
        console.log(`reviewId=${reviewId}, isLike=${isLike}`);

        const review = reviews.find(r => r.id == reviewId);
        if (!review) {
            return;
        }

        // Получаем текущую оценку пользователя
        const currentUserRating = getUserRating(reviewId);
        console.log(`Текущая оценка пользователя: ${currentUserRating}`);

        // Определяем действие для сервера - УПРОЩЕННАЯ ЛОГИКА
        let action;

        if (isLike) {
            // Если уже стоит лайк - снимаем (отправляем like повторно для снятия)
            // Сервер сам разберется с логикой снятия
            action = 'like';
        } else {
            // Если уже стоит дизлайк - снимаем (отправляем dislike повторно для снятия)
            action = 'dislike';
        }

        console.log(`Определено действие: ${action} (isLike=${isLike}, currentRating=${currentUserRating})`);

        // Отправляем запрос на сервер
        const response = await fetch(`/api/reviews/${reviewId}/rate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                action: action,
                user_token: userToken
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка сервера');
        }

        const data = await response.json();
        console.log('Ответ сервера:', data);

        // Обновляем данные отзыва
        updateReviewData(reviewId, data);

        // Обновляем UI
        updateReviewUI(reviewId, data.likes, data.dislikes, data.user_rating);

        // Показываем уведомление
        if (data.user_rating === null) {
        } else {
        }

        console.log(`=== ОЦЕНКА ЗАВЕРШЕНА ===`);

    } catch (error) {
        console.error('Ошибка при оценке отзыва:', error);
    }
}

// Функция получения текущей оценки пользователя
function getUserRating(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review || !review.user_ratings) return null;
    const rating = review.user_ratings[userToken] || null;
    console.log(`getUserRating: ${rating} для отзыва ${reviewId}`);
    return rating;
}

// ПРОСТАЯ функция обновления данных отзыва
function updateReviewData(reviewId, serverData) {
    const reviewIndex = reviews.findIndex(r => r.id == reviewId);

    if (reviewIndex !== -1) {
        console.log(`=== ОБНОВЛЕНИЕ ОТЗЫВА ${reviewId} ===`);

        // ПРОСТО заменяем объект отзыва
        reviews[reviewIndex] = {
            ...reviews[reviewIndex],
            ...serverData
        };

        console.log('Отзыв обновлен в массиве:', {
            user_token: reviews[reviewIndex].user_token,
            isAuthor: checkIsAuthor(reviews[reviewIndex])
        });

        // Сохраняем в localStorage
        saveRatingsToStorage();

        console.log('=== ОБНОВЛЕНИЕ ЗАВЕРШЕНО ===');
    } else {
        console.warn(`Отзыв ${reviewId} не найден в массиве`);
    }
}

// Дополнительная проверка перед отправкой
function validateRatingAction(isLike, currentUserRating) {
    if (isLike) {
        if (currentUserRating === 'like') {
            return 'remove_like';
        } else if (currentUserRating === 'dislike') {
            return 'like'; // Меняем дизлайк на лайк
        } else {
            return 'like'; // Ставим новый лайк
        }
    } else {
        if (currentUserRating === 'dislike') {
            return 'remove_dislike';
        } else if (currentUserRating === 'like') {
            return 'dislike'; // Меняем лайк на дизлайк
        } else {
            return 'dislike'; // Ставим новый дизлайк
        }
    }
}

// Вспомогательная функция для текста уведомления
function getRatingActionText(newRating, oldRating) {
    if (!oldRating) return 'поставлен';
    if (oldRating !== newRating) return 'изменен';
    return 'снят';
}

// Функция показа уведомления об оценке
function showRatingNotification(newRating, previousRating) {
    if (newRating === null) {
    } else if (previousRating && previousRating !== newRating) {
    }
}

// Функция для проверки работы сервера
async function testServerResponse() {
    try {
        const testData = {
            restaurant_id: 'lambs',
            username: 'test',
            rating: 5,
            comment: 'test',
            user_token: 'test_token_123',
            device_fingerprint: 'test_fingerprint_123'
        };

        console.log('=== ТЕСТ СЕРВЕРА ===');
        console.log('Отправляем:', testData);

        const response = await fetch('/api/reviews', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(testData)
        });

        const data = await response.json();
        console.log('Ответ сервера:', data);

        if (response.ok) {
            console.log('✅ Сервер работает корректно');
            console.log('user_token в ответе:', data.review?.user_token);
            console.log('device_fingerprint в ответе:', data.review?.device_fingerprint);
        } else {
            console.log('❌ Ошибка сервера:', data);
        }

    } catch (error) {
        console.error('Ошибка теста:', error);
    }
}

// Добавьте этот CSS для анимаций
const style = document.createElement('style');
style.textContent = `
    /* Стили для временной подсветки кнопок */
    .like-btn.highlight {
        color: #00a820;
        border: 2px solid #4CAF50;
        animation: likePulse 0.5s ease;
    }

    .dislike-btn.highlight {
        color: #ff0000;
        border: 2px solid #f44336;
        animation: dislikePulse 0.5s ease;
    }

    /* Анимация подсветки для лайка */
    @keyframes likePulse {
        0% {
            color: #00a820;
            transform: scale(1);
        }
        50% {
            color: #00a820;
            transform: scale(1.1);
        }
        100% {
            color: #00a820;
            transform: scale(1);
        }
    }

    /* Анимация подсветки для дизлайка */
    @keyframes dislikePulse {
        0% {
            color: red;
            transform: scale(1);
        }
        50% {
            color: red;
            transform: scale(1.1);
        }
        100% {
            color: red;
            transform: scale(1);
        }
    }

    /* Иконки при подсветке */
    .like-btn.highlight img {
        filter: none; /* Убираем инвертирование */
        /* Делаем иконку зеленой через фильтр */
        filter: brightness(0) saturate(100%) invert(48%) sepia(90%) saturate(1300%) hue-rotate(80deg) brightness(95%) contrast(105%);
    }

    .dislike-btn.highlight img {
        filter: none; /* Убираем инвертирование */
        /* Делаем иконку красной через фильтр */
        filter: brightness(0) saturate(100%) invert(27%) sepia(85%) saturate(7400%) hue-rotate(355deg) brightness(95%) contrast(120%);
    }

    /* Активные состояния (постоянные) */
    .like-btn.active {
        background-color: #4CAF50;
        color: black;
        border: 2px solid #4CAF50;
    }

    .dislike-btn.active {
        background-color: #f44336;
        color: black;
        border: 2px solid #f44336;
    }

    /* Анимация для отмены оценки */
    @keyframes cancelPulse {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(0.9);
            opacity: 0.7;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .like-btn.cancel, .dislike-btn.cancel {
        animation: cancelPulse 0.5s;
    }

    /* Убираем стандартную обводку у кнопок при фокусе */
    .like-btn:focus,
    .dislike-btn:focus,
    .like-btn:active,
    .dislike-btn:active {
        outline: none;
        box-shadow: none;
        border-color: transparent;
    }
`;
document.head.appendChild(style);

// Функция для отладки - показывает информацию о отзыве
function debugReviewInfo(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review) {
        console.log('Review not found');
        return;
    }

    console.log('=== REVIEW DEBUG INFO ===');
    console.log('Review ID:', review.id);
    console.log('User token in review:', review.user_token);
    console.log('Current user token:', userToken);
    console.log('Is same user:', review.user_token === userToken);
    console.log('Device fingerprint:', review.device_fingerprint);
    console.log('Current device fingerprint:', getDeviceFingerprint());
    console.log('Is same device:', isSameDevice(review));
    console.log('Created at:', review.created_at);
    console.log('Time difference (hours):', getTimeDifferenceHours(review.created_at));
    console.log('Can edit:', checkEditPermissionSync(review));
    console.log('Can delete:', checkDeletePermissionSync(review));
    console.log('=========================');
}

// Функция добавления оценки
function addRating(review, isLike) {
    if (isLike) {
        review.likes = (review.likes || 0) + 1;
    } else {
        review.dislikes = (review.dislikes || 0) + 1;
    }
}

// Функция для удаления оценки
async function removeRating(reviewId) {
    try {
        console.log(`Removing rating for review ${reviewId}`);

        // Определяем тип текущей оценки для снятия
        const isLike = currentUserRating === 'like';

        const response = await fetch(`/api/reviews/${reviewId}/rate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                is_like: isLike, // Отправляем текущий тип оценки для снятия
                user_token: userToken
            })
        });

        if (response.ok) {
            const data = await response.json();
            console.log('Server response:', data);

            updateReviewData(reviewId, data);

            // Сбрасываем текущую оценку пользователя
            currentUserRating = data.user_rating;
            updateLikeDislikeButtons();

        } else {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка сервера');
        }
    } catch (error) {
        console.error('Error removing rating:', error);
        throw error;
    }
}

// Функция обновления UI
function updateRatingUI(reviewId, likes, dislikes) {
    const modal = document.getElementById('full-review-modal');
    if (modal && modal.dataset.reviewId == reviewId) {
        const likeCountElem = modal.querySelector('.like-count');
        const dislikeCountElem = modal.querySelector('.dislike-count');

        if (likeCountElem) likeCountElem.textContent = likes || 0;
        if (dislikeCountElem) dislikeCountElem.textContent = dislikes || 0;
    }

    // Также обновляем карточку отзыва в списке
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        reviewElement.dataset.likes = likes || 0;
        reviewElement.dataset.dislikes = dislikes || 0;
    }
}

// Функция для полного сброса оценки пользователя
function resetUserRating(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review || !review.user_ratings) return;

    const userRating = review.user_ratings[userToken];
    if (!userRating) return;

    // Удаляем оценку
    if (userRating === 'like') {
        review.likes = Math.max(0, (review.likes || 0) - 1);
    } else {
        review.dislikes = Math.max(0, (review.dislikes || 0) - 1);
    }

    // Удаляем запись о оценке
    delete review.user_ratings[userToken];

    // Обновляем UI
    updateRatingUI(reviewId, review.likes, review.dislikes);
    saveRatingsToStorage();

}

// ===== ИНИЦИАЛИЗАЦИЯ =====
// Вызовите эту функцию после загрузки отзывов
async function loadReviews() {
    try {
        const response = await fetch(`/api/reviews?restaurant_id=${currentRestaurantId}&_=${Date.now()}`);

        if (response.ok) {
            const reviewsData = await response.json();

            // Сохраняем данные с сервера
            reviews = reviewsData;

            // Отображаем отзывы
            displayReviews(reviews);

            // Обновляем статистику
            initStats();
        } else {
            console.error('Ошибка загрузки отзывов');
        }
    } catch (error) {
        console.error('Error loading reviews:', error);
    }
}

// ПРОСТАЯ функция проверки авторства
function checkIsAuthor(review) {
    // Простая проверка: user_token должен совпадать
    const isAuthor = review.user_token === userToken;

    console.log('Author check:', {
        reviewToken: review.user_token,
        currentToken: userToken,
        isAuthor: isAuthor,
        reviewId: review.id
    });

    return isAuthor;
}

async function migrateMyLegacyReviews() {
    try {
        console.log('=== MIGRATING MY LEGACY REVIEWS ===');

        // Находим legacy отзывы с нашим username
        const myLegacyReviews = reviews.filter(review =>
            review.user_token &&
            review.user_token.startsWith('legacy_token_') &&
            // Здесь можно добавить дополнительную логику для определения своих отзывов
            // Например, по IP или другим признакам
            review.username === getCurrentUsername() // предположим, что есть такая функция
        );

        if (myLegacyReviews.length === 0) {
            console.log('No my legacy reviews found');
            return;
        }

        console.log(`Found ${myLegacyReviews.length} of my legacy reviews to migrate`);

        for (const review of myLegacyReviews) {
            console.log(`Migrating my review ${review.id}: ${review.user_token} -> ${userToken}`);

            // Отправляем запрос на сервер для миграции
            const response = await fetch(`/api/reviews/${review.id}/migrate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    user_token: userToken,
                    device_fingerprint: getDeviceFingerprint()
                })
            });

            if (response.ok) {
                const data = await response.json();
                console.log(`Review ${review.id} migrated successfully`);

                // Обновляем локальные данные
                review.user_token = userToken;
                review.device_fingerprint = getDeviceFingerprint();
            } else {
                console.error(`Failed to migrate review ${review.id}`);
            }
        }

        console.log('=== MY LEGACY REVIEWS MIGRATED ===');

    } catch (error) {
        console.error('Error migrating my legacy reviews:', error);
    }
}

// Вспомогательная функция для получения текущего username
function getCurrentUsername() {
    // Здесь должна быть логика получения текущего username
    // Например, из формы или из каких-то других данных
    return document.getElementById('name')?.value || 'Текущий пользователь';
}

// Функция для проверки данных отзывов
function debugReviews() {
    console.log('=== DEBUG REVIEWS ===');
    console.log('Current user token:', userToken);
    console.log('All reviews:', reviews);

    reviews.forEach((review, index) => {
        console.log(`Review ${index}:`, {
            id: review.id,
            user_token: review.user_token,
            device_fingerprint: review.device_fingerprint,
            canEdit: checkEditPermission(review)
        });
    });
}

// Функция для исправления user_token в существующих отзывах текущего пользователя
async function fixUserTokensForCurrentUser() {
    try {
        console.log('=== FIXING USER TOKENS FOR CURRENT USER ===');

        const reviewsToUpdate = reviews.filter(review =>
            (!review.user_token || review.user_token.startsWith('legacy_token_')) &&
            review.username // предположим, что отзывы с нашим username - наши
        );

        if (reviewsToUpdate.length === 0) {
            console.log('No reviews to fix');
            return;
        }

        console.log(`Found ${reviewsToUpdate.length} reviews to fix`);

        for (const review of reviewsToUpdate) {
            console.log(`Fixing review ${review.id}: ${review.user_token} -> ${userToken}`);
            review.user_token = userToken;
            review.device_fingerprint = getDeviceFingerprint();
        }

        // Перезагружаем UI чтобы применить изменения
        displayReviews(reviews);
        console.log('=== USER TOKENS FIXED ===');

    } catch (error) {
        console.error('Error fixing user tokens:', error);
    }
}

function debugReviewTokens() {
    console.log('=== DEBUG REVIEW TOKENS ===');
    console.log('Current user token:', userToken);
    console.log('All reviews:');

    reviews.forEach((review, index) => {
        const isCurrentUser = review.user_token === userToken;
        const isLegacy = review.user_token && review.user_token.startsWith('legacy_token_');

        console.log(`Review ${index + 1}:`, {
            id: review.id,
            username: review.username,
            user_token: review.user_token,
            is_current_user: isCurrentUser,
            is_legacy: isLegacy,
            should_show_buttons: isCurrentUser && !isLegacy
        });
    });
    console.log('===========================');
}
function debugReviewState(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review) {
        console.log('Review not found in array');
        return;
    }

    console.log('=== REVIEW DEBUG ===');
    console.log('ID:', review.id);
    console.log('User token in review:', review.user_token);
    console.log('Current user token:', userToken);
    console.log('Is author:', checkIsAuthor(review));
    console.log('Is legacy:', review.user_token.startsWith('legacy_token_'));
    console.log('====================');
}


// ===== ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ =====

// Функция для разворачивания/сворачивания текста
function toggleReviewExpand(reviewId) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (!reviewElement) return;

    reviewElement.classList.toggle('expanded');

    const button = reviewElement.querySelector('.expand-btn-bottom');
    if (button) {
        if (reviewElement.classList.contains('expanded')) {
            button.textContent = 'Свернуть';
        } else {
            button.textContent = 'Развернуть';
        }
    }
}

// Функция для установки оценки
async function setRating(isLike, reviewId) {
    try {
        console.log(`Setting rating: is_like=${isLike} for review ${reviewId}`);

        const response = await fetch(`/api/reviews/${reviewId}/rate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                is_like: isLike,
                user_token: userToken
            })
        });

        if (response.ok) {
            const data = await response.json();
            console.log('Server response:', data);

            updateReviewData(reviewId, data);

            // Обновляем текущую оценку пользователя
            currentUserRating = data.user_rating;
            updateLikeDislikeButtons();

        } else {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка сервера');
        }
    } catch (error) {
        console.error('Error setting rating:', error);
        throw error;
    }
}

// Функция сброса формы отзыва
function resetReviewForm() {
    document.getElementById('review-form').reset();
    // Сбрасываем звезды рейтинга
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });
    selectedRating = 0;
    document.getElementById('rating-error').style.display = 'none';
}

// Инициализация статистики при загрузке страницы
async function initStats() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurantId}/stats`);
        if (!response.ok) {
            throw new Error('Ошибка при загрузке статистики');
        }
        const stats = await response.json();
        updateRatingStats(stats);
    } catch (error) {
        // Устанавливаем значения по умолчанию
        document.getElementById('overall-rating').textContent = '0.0';
        document.getElementById('total-reviews').textContent = '0';

        // Сбрасываем все бары
        for (let i = 1; i <= 5; i++) {
            const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
            const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);
            if (bar) bar.style.width = '0%';
            if (countSpan) countSpan.textContent = '0';
        }
    }
}

// Локальное обновление статистики после добавления отзыва
function updateStatsLocally(newRating) {
    // Обновляем общее количество отзывов
    const totalReviewsElem = document.getElementById('total-reviews');
    const currentTotal = parseInt(totalReviewsElem.textContent) || 0;
    totalReviewsElem.textContent = currentTotal + 1;

    // Обновляем общий рейтинг
    const overallRatingElem = document.getElementById('overall-rating');
    const currentRating = parseFloat(overallRatingElem.textContent) || 0;
    const newOverallRating = ((currentRating * currentTotal) + newRating) / (currentTotal + 1);
    overallRatingElem.textContent = newOverallRating.toFixed(1);

    // Обновляем счетчик для конкретного рейтинга
    const ratingBars = document.querySelectorAll('.rating-bar');
    const targetBarIndex = 6 - newRating; // Индекс бара для этого рейтинга
    const targetBar = ratingBars[targetBarIndex - 1];

    if (targetBar) {
        const countSpan = targetBar.querySelector('span:last-child');
        const currentCount = parseInt(countSpan.textContent) || 0;
        countSpan.textContent = currentCount + 1;

        // Обновляем ширину заполнения
        const barFill = targetBar.querySelector('.fill');
        const newTotal = currentTotal + 1;
        const newPercentage = ((currentCount + 1) / newTotal) * 100;
        barFill.style.width = `${newPercentage}%`;
    }

    // Также обновляем все остальные бары (проценты меняются)
    updateAllBarsPercentages(currentTotal + 1);
}

// Функция для обновления процентов всех баров
function updateAllBarsPercentages(totalReviews) {
    if (totalReviews === 0) return;

    for (let i = 1; i <= 5; i++) {
        const barIndex = 6 - i;
        const bar = document.querySelector(`.rating-bar:nth-child(${barIndex})`);

        if (bar) {
            const countSpan = bar.querySelector('span:last-child');
            const count = parseInt(countSpan.textContent) || 0;
            const percentage = (count / totalReviews) * 100;

            const barFill = bar.querySelector('.fill');
            barFill.style.width = `${percentage}%`;
        }
    }
}

// Обработчик изменения размера окна
// При полной загрузке окна
window.addEventListener('load', function() {
    console.log('Window fully loaded - updating scroll');
    setTimeout(updateScrollButtons, 300);
});

// При изменении размера окна
window.addEventListener('resize', function() {
    setTimeout(updateScrollButtons, 200);
});

// При любых изменениях DOM (MutationObserver)
const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
            setTimeout(updateScrollButtons, 100);
        }
    });
});

// Начинаем наблюдение
const reviewList = document.getElementById('review-list');
if (reviewList) {
    observer.observe(reviewList, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style']
    });
}

// Функция для обновления общего рейтинга (только для синхронизации)
async function updateOverallRating() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurantId}/stats`);
        if (!response.ok) return; // Не бросаем ошибку, т.к. это фоновое обновление

        const stats = await response.json();
        updateRatingStats(stats);
    } catch (error) {
        console.error('Error updating overall rating:', error);
        // Не показываем уведомление, т.к. это фоновый процесс
    }
}

// Вызываем эту функцию при загрузке страницы и после добавления отзыва
document.addEventListener('DOMContentLoaded', () => {
    updateOverallRating();
    loadReviews();
});

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    // Инициализация звезд рейтинга
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.addEventListener('click', () => {
            selectedRating = parseInt(star.getAttribute('data-value'));
            stars.forEach((s, index) => {
                s.innerHTML = `<img src="${index < selectedRating ? PATHS.starActive : PATHS.starInactive}" alt="★">`;
            });
            document.getElementById('rating-error').style.display = 'none';
        });
    });

    // Загрузка отзывов
    loadReviews();
});


















// Функция для показа уведомлений
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Абсолютно надежная функция закрытия
function closeReviewModal() {
    const modal = document.getElementById('review-modal');
    if (modal) {
        modal.style.display = 'none';
    }

    // Сбрасываем форму
    const form = document.getElementById('review-form');
    if (form) {
        form.reset();
    }

    // Сбрасываем звезды
    const stars = document.querySelectorAll('#review-stars .star');
    stars.forEach(star => {
        star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
    });

    selectedRating = 0;
}








// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    loadReviews();
});

function initFavorites() {
  updateFavoritesVisibility();

  window.addEventListener('storage', function(event) {
    if (event.key === 'favorites') {
      updateFavoritesVisibility();
    }
  });
}

// Основная функция переключения
function toggleFavorite(itemId, itemData) {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};

  if (favorites[itemId]) {
    delete favorites[itemId];
  } else {
    favorites[itemId] = itemData;
  }

  localStorage.setItem('favorites', JSON.stringify(favorites));

  // Принудительное обновление интерфейса
  forceUIUpdate();

  // Оповещение других вкладок
  window.dispatchEvent(new Event('storageUpdate'));
}

// Обновление интерфейса с анимацией
function forceUIUpdate() {
  const headerBtn = document.getElementById('header-favorites-btn');
  if (headerBtn) {
    // 1. Добавляем класс для анимации исчезновения
    headerBtn.classList.add('hide');

    // 2. Через 300ms (длительность анимации) обновляем состояние
    setTimeout(() => {
      updateFavoritesVisibility();
      headerBtn.classList.remove('hide');
    }, 300);
  } else {
    updateFavoritesVisibility();
  }
}

// Контроль видимости кнопки
function updateFavoritesVisibility() {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};
  const count = Object.keys(favorites).length;
  const headerBtn = document.getElementById('header-favorites-btn');
  const counter = document.getElementById('favorites-count');

  if (counter) counter.textContent = count;

  if (!headerBtn) return;

  if (count > 0) {
    showHeaderButton();
  } else {
    hideHeaderButton();
  }
}

// Показать кнопку в шапке
function showHeaderButton() {
  const btn = document.getElementById('header-favorites-btn');
  if (!btn.classList.contains('visible')) {
    btn.style.display = 'inline-block';
    setTimeout(() => {
      btn.classList.add('visible');
    }, 10);
  }
}

// Скрыть кнопку с анимацией
function hideHeaderButton() {
  const btn = document.getElementById('header-favorites-btn');
  if (btn.classList.contains('visible')) {
    btn.classList.remove('visible');
    setTimeout(() => {
      btn.style.display = 'none';
    }, 300); // Должно совпадать с длительностью transition
  }
}

// Обновление счетчика и видимости кнопки
function updateFavoritesCount() {
  const favorites = JSON.parse(localStorage.getItem('favorites')) || {};
  const count = Object.keys(favorites).length;
  const counter = document.getElementById('favorites-count');
  const headerBtn = document.getElementById('header-favorites-btn');

  if (counter) counter.textContent = count;

  if (headerBtn) {
    if (count > 0) {
      showHeaderButton();
    } else {
      hideHeaderButton();
    }
  }
}


    // Функции для окон входа/регистрации
    function showWindow() {
        document.getElementById('overlay').style.display = 'block';
        const windowElement = document.getElementById('content_window');
        windowElement.classList.add('show');
        windowElement.style.display = 'block';
        document.body.classList.add('no-scroll');
    }

    function hideWindow() {
        document.getElementById('overlay').style.display = 'none';
        const windowElement = document.getElementById('content_window');
        windowElement.classList.remove('show');
        windowElement.style.display = 'none';
        document.body.classList.remove('no-scroll');
    }

    function showWindow1() {
        document.getElementById('overlay').style.display = 'block';
        const windowElement = document.getElementById('content_window2');
        windowElement.classList.add('show');
        windowElement.style.display = 'block';
        document.body.classList.add('no-scroll');
    }

    function hideWindow1() {
        document.getElementById('overlay').style.display = 'none';
        const windowElement = document.getElementById('content_window2');
        windowElement.classList.remove('show');
        windowElement.style.display = 'none';
        document.body.classList.remove('no-scroll');
    }

    // Закрытие окна при клике вне его
    document.getElementById('overlay').addEventListener('click', function() {
        const window1 = document.getElementById('content_window');
        const window2 = document.getElementById('content_window2');
        if (window1.classList.contains('show')) {
            hideWindow();
        } else if (window2.classList.contains('show')) {
            hideWindow1();
        }
    });

    // Обработчик для формы регистрации
    document.getElementById('regForm').onsubmit = function(event) {
        event.preventDefault();

        const username = document.getElementById('username1').value;
        const password = document.getElementById('password1').value;
        const confirmPassword = document.getElementById('password2').value;
        const secretKey = document.getElementById('secret_key').value;

        if (password !== confirmPassword) {
            alert('Пароли не совпадают');
            return;
        }

        fetch('/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'username': username,
                'password': password,
                'secret_key': secretKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('welcomeUser').innerText = data.username;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
                hideWindow1();
                localStorage.setItem('username', data.username);
            } else {
                alert(data.message);
            }
        });
    };

    // Обработчик для формы входа
    document.getElementById('loginForm').onsubmit = function(event) {
        event.preventDefault();

        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;

        fetch('/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'username': username,
                'password': password
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('welcomeUser').innerText = data.username;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
                hideWindow();
                localStorage.setItem('username', data.username);
            } else {
                alert(data.message);
            }
        });
    };

    // Функция выхода
    function logout() {
        fetch('/logout', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('loginButton').style.display = 'block';
                document.getElementById('registerButton').style.display = 'block';
                localStorage.removeItem('username');
            } else {
                alert(data.message);
            }
        });
    }

    // Проверка состояния пользователя при загрузке страницы
    window.addEventListener('load', function() {
        const username = localStorage.getItem('username');
        if (username) {
            document.getElementById('welcomeUser').innerText = username;
            document.getElementById('userInfo').style.display = 'flex';
            document.getElementById('loginButton').style.display = 'none';
            document.getElementById('registerButton').style.display = 'none';
        }

        // Инициализация менеджера избранного
        FavoritesManager.init();
    });

    // Синхронизация состояния пользователя между вкладками
    window.addEventListener('storage', function(event) {
        if (event.key === 'username') {
            if (event.newValue) {
                document.getElementById('welcomeUser').innerText = event.newValue;
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                document.getElementById('registerButton').style.display = 'none';
            } else {
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('loginButton').style.display = 'block';
                document.getElementById('registerButton').style.display = 'block';
            }
        }
    });

    // Менеджер избранного из старого HTML
    const FavoritesManager = {
        init: function() {
            this.bindEvents();
            this.updateCounter();
            this.markExistingFavorites();
        },

        bindEvents: function() {
            document.querySelectorAll('.js-favorite-btn').forEach(btn => {
                btn.addEventListener('click', this.handleFavoriteClick.bind(this));
            });
        },

        handleFavoriteClick: function(event) {
            const button = event.currentTarget;
            if (!button) return;

            try {
                const itemData = button.getAttribute('data-item');
                if (!itemData) {
                    console.error('No data-item attribute found');
                    return;
                }

                const item = JSON.parse(itemData);
                if (!item || !item.id) {
                    console.error('Invalid item data');
                    return;
                }

                const favorites = this.getFavorites();
                const existingIndex = favorites.findIndex(fav => fav.id === item.id);

                if (existingIndex === -1) {
                    favorites.push(item);
                    button.classList.add('active');
                    this.showNotification(`"${item.name}" добавлен в избранное`);
                } else {
                    favorites.splice(existingIndex, 1);
                    button.classList.remove('active');
                    this.showNotification(`"${item.name}" удален из избранного`);
                }

                this.saveFavorites(favorites);
                this.updateCounter();
            } catch (error) {
                console.error('Error handling favorite click:', error);
            }
        },

        markExistingFavorites: function() {
            const favorites = this.getFavorites();
            document.querySelectorAll('.js-favorite-btn').forEach(btn => {
                try {
                    const itemData = btn.getAttribute('data-item');
                    if (!itemData) return;

                    const item = JSON.parse(itemData);
                    if (item && item.id && favorites.some(fav => fav.id === item.id)) {
                        btn.classList.add('active');
                    }
                } catch (error) {
                    console.error('Error marking existing favorite:', error);
                }
            });
        },

        getFavorites: function() {
            try {
                return JSON.parse(localStorage.getItem('favorites')) || [];
            } catch (error) {
                console.error('Error getting favorites:', error);
                return [];
            }
        },

        saveFavorites: function(favorites) {
            try {
                localStorage.setItem('favorites', JSON.stringify(favorites));
            } catch (error) {
                console.error('Error saving favorites:', error);
            }
        },

        updateCounter: function() {
            try {
                const count = this.getFavorites().length;
                const counter = document.getElementById('favorites-count');
                if (counter) counter.textContent = count;
            } catch (error) {
                console.error('Error updating counter:', error);
            }
        },

        showNotification: function(message) {
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = 'rgba(0,0,0,0.8)';
            notification.style.color = 'white';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '5px';
            notification.style.zIndex = '1000';
            notification.style.transition = 'opacity 0.5s';
            notification.textContent = message;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }
    };

    // Переворот карточки
    function flipCard() {
        document.querySelector('.image-flip-container').classList.toggle('flipped');
    }

    // Развернуть изображение
    function expandImage(btn) {
        const img = btn.closest('.image-front').querySelector('img');
        const imgSrc = img.src;

        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.9)';
        overlay.style.display = 'flex';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '1000';
        overlay.style.cursor = 'zoom-out';

        const expandedImg = document.createElement('img');
        expandedImg.src = imgSrc;
        expandedImg.style.maxWidth = '90%';
        expandedImg.style.maxHeight = '90%';
        expandedImg.style.objectFit = 'contain';

        overlay.appendChild(expandedImg);
        overlay.onclick = function() {
            document.body.removeChild(overlay);
        };

        document.body.appendChild(overlay);
    }

    // Модальное окно для меню
    function openMenuModal() {
        document.getElementById('menu-modal').style.display = 'flex';
    }
    function closeMenuModal() {
        document.getElementById('menu-modal').style.display = 'none';
    }

    // Модальное окно для отзыва
    function openReviewModal() {
        // Генерируем/проверяем токен ДО открытия окна
        if (!localStorage.getItem('userToken')) {
            userToken = generateUserToken();
        }

        document.getElementById('review-modal').style.display = 'flex';
    }
    // Закрытие модального окна при клике вне его области
    document.getElementById('review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReviewModal();
        }
    });

    // Обработчик для кнопки закрытия
    document.querySelector('#review-modal .close').addEventListener('click', function() {
        closeReviewModal();
    });

    function filterReviewsByRating(rating) {
    const reviewList = document.getElementById('review-list');
    const reviewCards = reviewList.querySelectorAll('.review-card');
    let hasMatches = false;

    // Удаляем старое сообщение "Нет отзывов"
    const oldMsg = document.getElementById('no-reviews-message');
    if (oldMsg) oldMsg.remove();

    // Фильтруем отзывы (включая те, что еще не в БД)
    reviewCards.forEach(card => {
        // Ищем рейтинг двумя способами (для отзывов из БД и новых)
        let cardRating;

        // Способ 1: По заполненным звездам (работает для всех отзывов)
        const filledStars = card.querySelectorAll('.review-rating img[src*="baka.png"]');
        if (filledStars.length > 0) {
            cardRating = filledStars.length;
        }
        // Способ 2: По data-атрибуту (для новых отзывов)
        else {
            const ratingElem = card.querySelector('.rating');
            cardRating = ratingElem ? parseInt(ratingElem.dataset.rating) : 0;
        }

        if (rating === 0 || cardRating === rating) {
            card.style.display = 'flex';
            hasMatches = true;
        } else {
            card.style.display = 'none';
        }
    });

    // Показываем сообщение если нет совпадений
    if (!hasMatches && rating !== 0) {
        const msg = document.createElement('div');
        msg.id = 'no-reviews-message';
        msg.textContent = 'Таких отзывов нет!';
        msg.style.textAlign = 'center';
        msg.style.padding = '20px';
        msg.style.color = '#666';
        msg.style.width = '100%';
        reviewList.appendChild(msg);
    }

    // Всегда обновляем кнопки прокрутки после фильтрации
    setTimeout(updateScrollButtons, 150);
}

    // Обновленный обработчик звезд фильтра
    const filterStars = document.querySelectorAll('#filter-stars .star');
    let currentFilter = {
        rating: 0,      // Фильтр по звездам (0 - все)
        reaction: 'none' // Фильтр по реакциям ('none', 'likes', 'dislikes')
    };

    filterStars.forEach(star => {
        star.addEventListener('click', function() {
            const value = parseInt(this.getAttribute('data-value'));

            // Если кликнули на уже выбранную звезду - сбрасываем фильтр
            if (currentFilter === value) {
                currentFilter = 0;
                filterStars.forEach(s => {
                    s.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
                });
            } else {
                currentFilter = value;
                // Подсвечиваем звезды до выбранного значения
                filterStars.forEach((s, index) => {
                    const starValue = index + 1;
                    s.innerHTML = `<img src="${starValue <= value ? PATHS.starActive : PATHS.starInactive}"
                                       alt="★">`;
                });
            }

            filterReviewsByRating(currentFilter);
        });
    });

    // Обработчики для кнопок реакций
    const filterButtons = document.querySelectorAll('.filter-btn[data-type]');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const filterType = this.getAttribute('data-type');

            // Если кликаем на уже активную кнопку - сбрасываем
            if (currentFilter.reaction === filterType) {
                currentFilter.reaction = 'none';
                filterButtons.forEach(b => b.classList.remove('active'));
                document.querySelector('.filter-btn[data-type="none"]').classList.add('active');
            } else {
                // Устанавливаем новый фильтр
                currentFilter.reaction = filterType;
                filterButtons.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            }

            applyFilters();
        });
    });


    // Функция показа всех отзывов
    function showAllReviews() {
        currentFilter = 0;
        filterStars.forEach(star => {
            star.innerHTML = `<img src="${PATHS.starInactive}" alt="★">`;
        });
        filterReviewsByRating(0);
    }

    // Лайки и дизлайки
    let likeCount = 0;
    let dislikeCount = 0;

// ===== ОБНОВЛЕННЫЕ ОБРАБОТЧИКИ КНОПОК =====

// Функции для лайка и дизлайка
function likeReview() {
    if (!currentReviewId) return;
    rateReview(true, currentReviewId);
}

function dislikeReview() {
    if (!currentReviewId) return;
    rateReview(false, currentReviewId);
}

    // Оценка звёздами
    const stars = document.querySelectorAll('#review-stars .star');

    stars.forEach(star => {
        star.addEventListener('click', () => {
            const value = parseFloat(star.getAttribute('data-value'));
            selectedRating = value; // Сохраняем выбранную оценку

            stars.forEach((s, index) => {
                const starValue = parseFloat(s.getAttribute('data-value'));
                if (starValue <= value) {
                    s.innerHTML = `<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★" style="width: 24px; height: 24px;">`;
                } else {
                    s.innerHTML = `<img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★" style="width: 24px; height: 24px;">`;
                }
            });
        });
    });

    // Функция для отладки состояния оценок
function debugRatings(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review) {
        console.log('Отзыв не найден');
        return;
    }

    console.log('=== ДЕБАГ ОЦЕНОК ===');
    console.log('ID отзыва:', reviewId);
    console.log('Лайки:', review.likes);
    console.log('Дизлайки:', review.dislikes);
    console.log('User ratings:', review.user_ratings);
    console.log('Текущий user token:', userToken);
    console.log('Оценка текущего пользователя:', review.user_ratings?.[userToken]);
    console.log('===================');
}

// Вызывайте эту функцию при необходимости отладки
// debugRatings(currentReviewId);


    reviewList.scrollTo({
        left: 0,
        behavior: 'smooth'
    });

    // Закрытие модального окна при клике вне его области
    document.getElementById('full-review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeFullReviewModal();
        }
    });

// Функция закрытия модального окна
function closeFullReviewModal() {
    const modal = document.getElementById('full-review-modal');
    if (modal) {
        modal.style.display = 'none';
        currentReviewId = null;
        currentUserRating = null;
    }
}

// Функция обработки лайка/дизлайка
async function handleReaction(isLike) {
    if (!currentReviewId) {
        return;
    }

    try {
        const review = reviews.find(r => r.id == currentReviewId);
        if (!review) {
            return;
        }

        // Анимация нажатия
        const likeBtn = document.querySelector('#full-review-modal .like-btn');
        const dislikeBtn = document.querySelector('#full-review-modal .dislike-btn');

        if (isLike && likeBtn) {
            likeBtn.classList.add('click-animation');
            setTimeout(() => likeBtn.classList.remove('click-animation'), 300);
        } else if (!isLike && dislikeBtn) {
            dislikeBtn.classList.add('click-animation');
            setTimeout(() => dislikeBtn.classList.remove('click-animation'), 300);
        }

        // Логика переключения оценок
        if (currentUserRating === (isLike ? 'like' : 'dislike')) {
            // Если кликаем на уже активную кнопку - снимаем оценку
            await removeRating(currentReviewId);
        } else {
            // Если выбираем другую оценку - меняем
            await setRating(isLike, currentReviewId);
        }

    } catch (error) {
        console.error('Error handling reaction:', error);
    }
}

    function updateLikeDislikeHandlers(reviewId) {
    const likeBtn = document.querySelector('#full-review-modal .like-btn');
    const dislikeBtn = document.querySelector('#full-review-modal .dislike-btn');

    if (likeBtn) {
        likeBtn.onclick = () => handleReaction(true, reviewId);
    }
    if (dislikeBtn) {
        dislikeBtn.onclick = () => handleReaction(false, reviewId);
    }
}

// ===== ОБНОВЛЕННАЯ ФУНКЦИЯ ОТКРЫТИЯ МОДАЛЬНОГО ОКНА =====
// Улучшенная функция открытия модального окна
function openFullReviewModal(reviewId) {
    console.log('Opening full review modal for ID:', reviewId);

    // Ищем актуальные данные отзыва
    let reviewData = reviews.find(r => r.id == reviewId);

    if (!reviewData) {
        console.error('Review not found in local array:', reviewId);
        return;
    }

    const modal = document.getElementById('full-review-modal');
    if (!modal) {
        console.error('Modal not found');
        return;
    }

    // Сохраняем ID текущего отзыва
    currentReviewId = reviewId;
    modal.dataset.reviewId = reviewId;

    // Заполняем модальное окно данными
    const reviewNameElem = modal.querySelector('.review-name');
    const reviewRatingElem = modal.querySelector('.review-rating');
    const reviewCommentElem = modal.querySelector('.review-comment');
    const likeCountElem = modal.querySelector('.like-count');
    const dislikeCountElem = modal.querySelector('.dislike-count');

    if (reviewNameElem) reviewNameElem.textContent = reviewData.username;
    if (reviewCommentElem) reviewCommentElem.textContent = reviewData.comment;

    // Обновляем счетчики лайков/дизлайков
    if (likeCountElem) likeCountElem.textContent = reviewData.likes || 0;
    if (dislikeCountElem) dislikeCountElem.textContent = reviewData.dislikes || 0;

    // Создаем HTML для звезд рейтинга
    let starsHTML = '';
    for (let i = 0; i < 5; i++) {
        if (i < reviewData.rating) {
            starsHTML += `<img src="${PATHS.starActive}" alt="★" style="width:20px;height:20px;">`;
        } else {
            starsHTML += `<img src="${PATHS.starInactive}" alt="★" style="width:20px;height:20px;">`;
        }
    }
    if (reviewRatingElem) reviewRatingElem.innerHTML = starsHTML;

    // Получаем текущую оценку пользователя
    currentUserRating = getUserRating(reviewId);

    // Обновляем UI оценок
    updateModalRatingUI(
        reviewData.likes || 0,
        reviewData.dislikes || 0,
        currentUserRating
    );

    // Удаляем старые кнопки перед добавлением новых
    const oldButtonsContainer = modal.querySelector('.modal-action-buttons');
    if (oldButtonsContainer) {
        oldButtonsContainer.remove();
    }

    // Добавляем кнопки редактирования/удаления
    addEditDeleteButtonsToModal(modal, reviewData);

    // Показываем модальное окно
    modal.style.display = 'flex';
}

// Функция для обновления состояния кнопок
function updateLikeDislikeButtons() {
    const likeBtn = document.querySelector('#full-review-modal .like-btn');
    const dislikeBtn = document.querySelector('#full-review-modal .dislike-btn');

    if (!likeBtn || !dislikeBtn) return;

    // Сбрасываем все активные состояния
    likeBtn.classList.remove('active');
    dislikeBtn.classList.remove('active');

    // Устанавливаем активное состояние
    if (currentUserRating === 'like') {
        likeBtn.classList.add('active');
    } else if (currentUserRating === 'dislike') {
        dislikeBtn.classList.add('active');
    }

    console.log(`Updated buttons: user_rating=${currentUserRating}`);
}

// ПЕРЕПИСАННАЯ функция для добавления кнопок редактирования и удаления
function addEditDeleteButtonsToModal(modal, reviewData) {
    console.log('=== ДОБАВЛЕНИЕ КНОПОК ДЛЯ ОТЗЫВА ===');

    // Удаляем старые кнопки и отладочную информацию
    const oldButtonsContainer = modal.querySelector('.modal-action-buttons');
    if (oldButtonsContainer) oldButtonsContainer.remove();

    // Удаляем старую отладочную информацию
    const oldDebugInfo = modal.querySelector('.debug-info');
    if (oldDebugInfo) oldDebugInfo.remove();

    // СТРОГАЯ проверка авторства - только по user_token
    const isAuthor = checkIsAuthor(reviewData);
    console.log('Author check result:', {
        isAuthor: isAuthor,
        reviewToken: reviewData.user_token,
        currentToken: userToken
    });

    // Если пользователь НЕ автор - НЕ показываем ничего (ни кнопок, ни отладки)
    if (!isAuthor) {
        console.log('Пользователь не автор - кнопки не показаны');
        return; // Просто выходим из функции
    }

    // ДОСТИГЛИ СЮДА ТОЛЬКО ЕСЛИ ПОЛЬЗОВАТЕЛЬ - АВТОР

    // Проверяем время для редактирования/удаления
    const canEdit = checkEditPermissionSync(reviewData);
    const canDelete = checkDeletePermissionSync(reviewData);

    console.log('Permissions for author:', { canEdit, canDelete });

    // Создаем контейнер для кнопок
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'modal-action-buttons';
    buttonsContainer.style.cssText = 'margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; display: flex; gap: 10px; flex-wrap: wrap;';

    // Кнопка редактирования (только для автора)
    if (canEdit) {
        const editButton = document.createElement('button');
        editButton.className = 'edit-review-btn';
        editButton.innerHTML = '✏️ Редактировать';
        editButton.style.cssText = 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
        editButton.onclick = (e) => {
            e.stopPropagation();
            closeFullReviewModal();
            setTimeout(() => {
                openEditReviewModal(reviewData.id, reviewData.rating, reviewData.comment);
            }, 100);
        };
        buttonsContainer.appendChild(editButton);
    } else {
        // Сообщение об истечении времени редактирования (ТОЛЬКО для автора)
        const timeMessage = document.createElement('div');
        timeMessage.className = 'edit-time-expired';
        timeMessage.innerHTML = '⏰ Время редактирования истекло (3 часа)';
        timeMessage.style.cssText = 'color: #ff6b6b; font-size: 14px; padding: 8px 12px; background: #fff5f5; border-radius: 4px; border: 1px solid #ffd6d6;';
        buttonsContainer.appendChild(timeMessage);
    }

    // Кнопка удаления (только для автора)
    if (canDelete) {
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-review-btn';
        deleteButton.innerHTML = '🗑️ Удалить';
        deleteButton.style.cssText = 'padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
        deleteButton.onclick = (e) => {
            e.stopPropagation();
            showCustomDeleteConfirmation(reviewData.id);
        };
        buttonsContainer.appendChild(deleteButton);
    } else {
        // Сообщение об истечении времени удаления (ТОЛЬКО для автора)
        const timeMessage = document.createElement('div');
        timeMessage.className = 'delete-time-expired';
        timeMessage.innerHTML = '⏰ Время удаления истекло (6 часов)';
        timeMessage.style.cssText = 'color: #ff9500; font-size: 14px; padding: 8px 12px; background: #fff4e6; border-radius: 4px; border: 1px solid #ffe0b2;';
        buttonsContainer.appendChild(timeMessage);
    }

    // Добавляем контейнер с кнопками в модальное окно (только если есть что показать)
    if (buttonsContainer.children.length > 0) {
        modal.querySelector('.modal-content').appendChild(buttonsContainer);
        console.log('Кнопки управления добавлены для автора');
    }

    console.log('=== КНОПКИ ДОБАВЛЕНЫ ТОЛЬКО ДЛЯ АВТОРА ===');
}

// Функция для показа кастомного подтверждения удаления
function showCustomDeleteConfirmation(reviewId) {
    // Создаем модальное окно подтверждения
    const confirmModal = document.createElement('div');
    confirmModal.id = 'delete-confirmation-modal';
    confirmModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;

    confirmModal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 10px; text-align: center; max-width: 400px; width: 90%;">
            <h3 style="margin-bottom: 20px; color: #333;">Удалить отзыв?</h3>
            <p style="margin-bottom: 25px; color: #666;">Вы уверены, что хотите удалить этот отзыв? Это действие нельзя отменить.</p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="cancel-delete" style="padding: 10px 25px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 5px; cursor: pointer;">Отмена</button>
                <button id="confirm-delete" style="padding: 10px 25px; border: none; background: #f44336; color: white; border-radius: 5px; cursor: pointer;">Удалить</button>
            </div>
        </div>
    `;

    document.body.appendChild(confirmModal);

    // Обработчики для кнопок
    document.getElementById('cancel-delete').onclick = function() {
        document.body.removeChild(confirmModal);
    };

    document.getElementById('confirm-delete').onclick = function() {
        document.body.removeChild(confirmModal);
        deleteReview(reviewId);
        closeFullReviewModal();
    };

    // Закрытие при клике вне модального окна
    confirmModal.onclick = function(e) {
        if (e.target === confirmModal) {
            document.body.removeChild(confirmModal);
        }
    };
}

// Закрытие модального окна редактирования при клике вне области
document.getElementById('edit-review-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        closeEditModal();
    }
});

// Закрытие по кнопке ×
document.querySelector('#edit-review-modal .close').addEventListener('click', closeEditModal);

// Функция для расчета разницы во времени в часах
function getTimeDifferenceHours(createdAt) {
    const created = new Date(createdAt);
    const now = new Date();
    return (now - created) / (1000 * 60 * 60);
}

// Улучшенная синхронная проверка прав на редактирование
function checkEditPermissionSync(review) {
    try {
        // Сначала проверяем является ли пользователь автором
        if (!checkIsAuthor(review)) {
            return false;
        }


        // Проверяем время (3 часа)
        const createdAt = new Date(review.created_at);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

        return hoursDiff <= 3;
    } catch (error) {
        return false;
    }
}

// Функция для миграции старых отзывов
async function migrateLegacyReviews() {
    try {
        console.log('Начинаем миграцию legacy-отзывов...');

        const response = await fetch('/api/migrate_legacy_reviews', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                user_token: userToken,
                device_fingerprint: getDeviceFingerprint()
            })
        });

        const data = await response.json();

        if (response.ok && data.success) {

            // Перезагружаем отзывы после миграции
            setTimeout(() => {
                loadReviews();
            }, 500);

            return true;
        } else {
            console.error('Ошибка миграции:', data);
            return false;
        }

    } catch (error) {
        console.error('Ошибка при миграции:', error);
        return false;
    }
}

// Функция для показа оставшегося времени
function getTimeLeftMessage(review) {
    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    const editTimeLeft = 3 - hoursDiff;
    const deleteTimeLeft = 6 - hoursDiff;

    if (editTimeLeft > 0) {
        return `Редактирование: ${Math.ceil(editTimeLeft)}ч | Удаление: ${Math.ceil(deleteTimeLeft)}ч`;
    } else if (deleteTimeLeft > 0) {
        return `Удаление: ${Math.ceil(deleteTimeLeft)}ч`;
    } else {
        return 'Время действий истекло';
    }
}

// Улучшенная синхронная проверка прав на удаление
function checkDeletePermissionSync(review) {
    try {
        // Сначала проверяем является ли пользователь автором
        if (!checkIsAuthor(review)) {
            return false;
        }

        // Legacy отзывы нельзя удалять
        if (review.user_token.startsWith('legacy_token_')) {
            return false;
        }

        // Проверяем время (6 часов)
        const createdAt = new Date(review.created_at);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

        return hoursDiff <= 6;
    } catch (error) {
        return false;
    }
}

    // При создании отзыва добавляем поле для отслеживания голосов
    const review = {
        id: Date.now(),
        name: name,
        rating: selectedRating,
        comment: comment,
        likes: 0,
        dislikes: 0,
        userVoted: null // 'like', 'dislike' или null
    };

    // Функция для добавления кнопки редактирования в модальное окно
function addEditButtonToModal(modal, reviewData) {
    console.log('Adding edit button for review:', reviewData);

    // Удаляем старую кнопку редактирования если есть
    const oldEditBtn = modal.querySelector('.edit-review-btn');
    if (oldEditBtn) {
        oldEditBtn.remove();
    }

    // Проверяем можно ли редактировать отзыв
    const canEdit = checkEditPermission(reviewData);
    console.log('Can edit:', canEdit);

    // Создаем контейнер для кнопок
    let buttonsContainer = modal.querySelector('.modal-buttons-container');
    if (!buttonsContainer) {
        buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'modal-buttons-container';
        modal.querySelector('.modal-content').appendChild(buttonsContainer);
    }

    // Создаем кнопку редактирования
    const editButton = document.createElement('button');
    editButton.className = `edit-review-btn ${canEdit ? '' : 'disabled'}`;
    editButton.innerHTML = '✏️ Редактировать';
    editButton.dataset.reviewId = reviewData.id;

    if (canEdit) {
        editButton.onclick = () => {
            console.log('Edit button clicked for review:', reviewData.id);
            openEditReviewModal(reviewData.id, reviewData.rating, reviewData.comment);
        };
    } else {
        editButton.onclick = () => {
            console.log('Edit button clicked but disabled for review:', reviewData.id);
            showEditTimeExpiredMessage(reviewData);
        };
        editButton.title = 'Время редактирования истекло или недоступно';
    }

    buttonsContainer.appendChild(editButton);
    console.log('Edit button added:', editButton);
}

// Функция показа сообщения об истечении времени редактирования
function showEditTimeExpiredMessage(review) {
    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    let message;

    if (hoursDiff > 3) {
        message = 'У тебя было 3 часа чтобы всё исправить. Время редактирования истекло!';
    } else if (review.user_token !== userToken) {
        message = 'Это не твой отзыв! Редактирование запрещено.';
    } else if (!isSameDevice(review)) {
        message = 'Редактирование разрешено только с того же устройства!';
    } else {
        message = 'Редактирование невозможно по неизвестной причине.';
    }


    // Анимация кнопки
    const editButton = document.querySelector('#full-review-modal .edit-review-btn');
    if (editButton) {
        editButton.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
            editButton.style.animation = '';
        }, 500);
    }
}

// Функция для принудительного обновления счетчиков
function updateCountersManually() {
    const modal = document.getElementById('full-review-modal');
    if (!modal) return;

    const reviewId = modal.dataset.reviewId;
    if (!reviewId) return;

    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    const reviewData = reviews.find(r => r.id == reviewId);

    if (reviewData) {
        const likeCountElem = modal.querySelector('.like-count');
        const dislikeCountElem = modal.querySelector('.dislike-count');

        if (likeCountElem) likeCountElem.textContent = reviewData.likes || 0;
        if (dislikeCountElem) dislikeCountElem.textContent = reviewData.dislikes || 0;

        if (reviewElement) {
            reviewElement.dataset.likes = reviewData.likes || 0;
            reviewElement.dataset.dislikes = reviewData.dislikes || 0;
        }
    }
}

// Вызовите эту функцию если нужно принудительно обновить

    // Функция для ограничения высоты текста
    // Функция для ограничения высоты длинных комментариев
function limitCommentHeight(reviewElement) {
    const container = reviewElement.querySelector('.comment-container');
    const text = reviewElement.querySelector('.comment-text');
    const blur = reviewElement.querySelector('.comment-blur');

    if (text.scrollHeight > text.clientHeight) {
        blur.style.display = 'block';
    } else {
        blur.style.display = 'none';
    }
}

    // Общая оценка и статистика
    let overallRating = 0;
    let ratingCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

    // Функция для обновления статистики отзывов
    function updateRatingBars() {
        const totalReviews = reviews.length;
        for (let i = 1; i <= 5; i++) {
            const count = ratingCounts[i];
            const percentage = totalReviews === 0 ? 0 : (count / totalReviews) * 100;
            const bar = document.querySelector(`.rating-bar:nth-child(${6 - i}) .fill`);
            const countSpan = document.querySelector(`.rating-bar:nth-child(${6 - i}) span:last-child`);
            bar.style.width = `${percentage}%`;
            countSpan.textContent = count;
        }
    }

    // Функция для прокрутки отзывов
function scrollReviews(direction) {
    const reviewList = document.getElementById('review-list');
    const scrollAmount = 320; // Фиксированное значение

    if (direction === 'left') {
        reviewList.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
    } else {
        reviewList.scrollBy({ left: scrollAmount, behavior: 'smooth' });
    }

    // Обновляем кнопки после прокрутки
    setTimeout(updateScrollButtons, 350);
}

function updateScrollButtons() {
    const reviewList = document.getElementById('review-list');
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!reviewList || !leftButton || !rightButton) {
        console.log('Scroll elements not found');
        return;
    }

    // Ждем следующего tick'а для обновления DOM
    setTimeout(() => {
        try {
            // Проверяем видимые отзывы
            const visibleReviews = Array.from(reviewList.children).filter(card =>
                card.style.display !== 'none' && window.getComputedStyle(card).display !== 'none'
            );

            const hasVisibleReviews = visibleReviews.length > 0;
            const canScroll = reviewList.scrollWidth > reviewList.clientWidth + 2; // +2 для погрешности

            console.log('Scroll state:', {
                visibleReviews: visibleReviews.length,
                scrollWidth: reviewList.scrollWidth,
                clientWidth: reviewList.clientWidth,
                canScroll: canScroll,
                scrollLeft: reviewList.scrollLeft
            });

            if (hasVisibleReviews && canScroll) {
                // Показываем кнопки
                leftButton.style.display = 'flex';
                rightButton.style.display = 'flex';

                // Обновляем состояния
                const canScrollLeft = reviewList.scrollLeft > 5;
                const canScrollRight = reviewList.scrollLeft + reviewList.clientWidth < reviewList.scrollWidth - 5;

                leftButton.style.opacity = canScrollLeft ? '1' : '0.3';
                rightButton.style.opacity = canScrollRight ? '1' : '0.3';
                leftButton.style.pointerEvents = canScrollLeft ? 'auto' : 'none';
                rightButton.style.pointerEvents = canScrollRight ? 'auto' : 'none';
            } else {
                // Скрываем кнопки
                leftButton.style.display = 'none';
                rightButton.style.display = 'none';
            }
        } catch (error) {
            console.error('Error in updateScrollButtons:', error);
        }
    }, 50);
}

// Функция для обновления отображения после фильтрации
function updateReviewVisibility() {
    const reviewList = document.getElementById('review-list');
    if (!reviewList) return;

    // Принудительно обновляем скролл
    setTimeout(() => {
        updateScrollButtons();
        // Дополнительная проверка через 500ms
        setTimeout(updateScrollButtons, 500);
    }, 100);
}

// Обновление состояния стрелочек при прокрутке
reviewList.addEventListener('scroll', function() {
    const leftButton = document.querySelector('.scroll-button.left');
    const rightButton = document.querySelector('.scroll-button.right');

    if (!leftButton || !rightButton) return;

    const canScrollLeft = this.scrollLeft > 0;
    const canScrollRight = this.scrollLeft + this.clientWidth < this.scrollWidth - 1;

    leftButton.style.opacity = canScrollLeft ? '1' : '0.5';
    leftButton.style.pointerEvents = canScrollLeft ? 'auto' : 'none';

    rightButton.style.opacity = canScrollRight ? '1' : '0.5';
    rightButton.style.pointerEvents = canScrollRight ? 'auto' : 'none';
});

    // Функция для разворачивания отзыва
function expandReview(reviewId) {
    const review = reviews.find(r => r.id === reviewId);
    if (!review) return;

    const modal = document.getElementById('full-review-modal');
    modal.querySelector('.review-name').textContent = review.username;
    modal.querySelector('.review-rating').innerHTML =
        `${'<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★" style="width:20px;height:20px;">'.repeat(review.rating)}`;
    modal.querySelector('.review-comment').textContent = review.comment;
    modal.style.display = 'flex';
}

// Глобальные переменные
let currentUser = null; // Должно устанавливаться при авторизации
let currentRestaurant = {
    id: 'lambs',
    name: 'Барашки'
};

// Функция для проверки можно ли редактировать отзыв
function checkReviewEditAbility(review) {
    if (!review.can_edit) return false;

    const createdAt = new Date(review.created_at);
    const now = new Date();
    const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

    return hoursDiff <= 3;
}

// Функция для загрузки данных ресторана и отзывов
async function loadRestaurantData() {
    try {
        const response = await fetch(`/api/restaurants/${currentRestaurant.id}`);
        const data = await response.json();

        if (!response.ok) {
            throw new Error('Ошибка при загрузке данных');
        }

        // Обновляем рейтинг ресторана
        updateRestaurantRating(data.restaurant.rating, data.restaurant.review_count);

        // Очищаем и добавляем отзывы
        document.getElementById('reviews-list').innerHTML = '';
        data.reviews.forEach(review => {
            addReviewToUI(review);
        });
    } catch (error) {
    }
}

// Вспомогательные функции для обновления UI
function updateRestaurantRating(rating, count) {
    if (rating) {
        document.querySelector('.overall-rating .rating-value').textContent = rating.toFixed(1);
        document.querySelector('.restaurant-rating .rating-value').textContent = rating.toFixed(1);
    }
    if (count) {
        document.querySelector('.overall-rating .reviews-count').textContent = `${count} отзывов`;
    }
}

function addReviewToUI(review) {
    const reviewsContainer = document.getElementById('review-list');

    // Удаляем сообщение "Нет отзывов", если оно есть
    const noReviewsMsg = reviewsContainer.querySelector('.no-reviews');
    if (noReviewsMsg) {
        noReviewsMsg.remove();
    }

    const reviewElement = document.createElement('div');
    reviewElement.className = 'review-card';
    reviewElement.dataset.reviewId = review.id;

    reviewElement.innerHTML = `
        <div class="review-header">
            <img class="avatar" src="{{ url_for('static', filename='Фотки зданий/avatar.png') }}" alt="Аватар">
            <div class="name-rating">
                <div class="name">${review.username}</div>
                <div class="rating">
                    ${'<img src="{{ url_for('static', filename='Фотки зданий/baka.png') }}" alt="★">'.repeat(review.rating)}
                    ${'<img src="{{ url_for('static', filename='Фотки зданий/star.png') }}" alt="★">'.repeat(5 - review.rating)}
                </div>
            </div>
        </div>
        <div class="comment-container">
            <div class="comment-text">${review.comment || ''}</div>
        </div>
        <div class="review-actions">
            <button class="like-btn" onclick="rateReview(true, ${review.id})">
                <img src="/static/Фотки зданий/Лайк.png" alt="Лайк">
                <span class="like-count">${review.likes || 0}</span>
            </button>
            <button class="dislike-btn" onclick="rateReview(false, ${review.id})">
                <img src="/static/Фотки зданий/Дизлайк.png" alt="Дизлайк">
                <span class="dislike-count">${review.dislikes || 0}</span>
            </button>

            ${checkEditPermission(review) ? `
            <button class="edit-btn" onclick="openEditReviewModal(${review.id}, ${review.rating}, '${review.comment}')">
                Редактировать
            </button>
            ` : ''}
        </div>
        <div class="review-date">${new Date(review.created_at).toLocaleString()}</div>
    `;

    // Добавляем новый отзыв в начало списка
    reviewsContainer.insertBefore(reviewElement, reviewsContainer.firstChild);

    // Добавляем анимацию появления
    reviewElement.style.opacity = '0';
    setTimeout(() => {
        reviewElement.style.transition = 'opacity 0.3s ease';
        reviewElement.style.opacity = '1';
    }, 10);
}

// Функция для принудительного обновления UI отзыва
function updateReviewInUI(reviewId, updatedData) {
    console.log('Обновление UI для отзыва:', reviewId, 'с данными:', updatedData);

    // 1. Обновляем карточку отзыва в списке - ОСНОВНОЕ!
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        console.log('Найден элемент отзыва для обновления');

        // Обновляем комментарий
        if (updatedData.comment !== undefined) {
            const commentElement = reviewElement.querySelector('.comment-text');
            if (commentElement) {
                commentElement.textContent = updatedData.comment;
                console.log('Комментарий обновлен:', updatedData.comment);
            }
        }

        // ОБНОВЛЯЕМ РЕЙТИНГ - ГЛАВНОЕ ИСПРАВЛЕНИЕ!
        if (updatedData.rating !== undefined) {
            const ratingElement = reviewElement.querySelector('.review-rating');
            if (ratingElement) {
                // Полностью пересоздаем HTML для звезд
                const newStarsHTML = createStarsHTML(updatedData.rating);
                console.log('Новые звезды:', newStarsHTML);

                ratingElement.innerHTML = newStarsHTML;
                console.log('Рейтинг обновлен в UI:', updatedData.rating);
            }
        }

        // Визуальный эффект обновления
        reviewElement.style.transition = 'all 0.3s ease';
        reviewElement.style.backgroundColor = '#f0fff0';
        setTimeout(() => {
            reviewElement.style.backgroundColor = '';
        }, 1000);
    } else {
        console.log('Элемент отзыва не найден, возможно нужно перезагрузить список');
    }

    // 2. Обновляем модальное окно если оно открыто
    const fullModal = document.getElementById('full-review-modal');
    if (fullModal && fullModal.dataset.reviewId == reviewId) {
        console.log('Обновляем открытое модальное окно');

        if (updatedData.comment !== undefined) {
            const commentElement = fullModal.querySelector('.review-comment');
            if (commentElement) {
                commentElement.textContent = updatedData.comment;
            }
        }

        if (updatedData.rating !== undefined) {
            const ratingElement = fullModal.querySelector('.review-rating');
            if (ratingElement) {
                ratingElement.innerHTML = createStarsHTML(updatedData.rating);
            }
        }
    }
}

// Функция для создания HTML звезд
function createStarsHTML(rating) {
    console.log('createStarsHTML вызвана с рейтингом:', rating);

    let starsHTML = '';
    for (let i = 0; i < 5; i++) {
        if (i < rating) {
            starsHTML += `<img src="${PATHS.starActive}" alt="★" style="width:20px;height:20px;">`;
            console.log(`Звезда ${i+1}: активная`);
        } else {
            starsHTML += `<img src="${PATHS.starInactive}" alt="★" style="width:20px;height:20px;">`;
            console.log(`Звезда ${i+1}: неактивная`);
        }
    }

    console.log('Итоговый HTML звезд:', starsHTML);
    return starsHTML;
}

// Функция для проверки конкретного отзыва в БД
async function checkReviewInDB(reviewId) {
    try {
        const response = await fetch(`/api/reviews?restaurant_id=${currentRestaurantId}`);
        const allReviews = await response.json();

        const targetReview = allReviews.find(r => r.id === reviewId);
        if (targetReview) {
            console.log('=== ПРОВЕРКА ОТЗЫВА ИЗ БД ===');
            console.log('ID:', targetReview.id);
            console.log('Username:', targetReview.username);
            console.log('User token в БД:', targetReview.user_token);
            console.log('Device fingerprint в БД:', targetReview.device_fingerprint);
            console.log('============================');
            return targetReview;
        } else {
            console.log('Отзыв не найден в БД');
            return null;
        }
    } catch (error) {
        console.error('Ошибка при проверке:', error);
        return null;
    }
}


// Функция для отладки - проверяет актуальность данных
function debugReviewData(reviewId) {
    const review = reviews.find(r => r.id == reviewId);
    if (!review) {
        console.log('Отзыв не найден в массиве reviews');
        return;
    }

    console.log('=== ДАННЫЕ ОТЗЫВА ===');
    console.log('ID:', review.id);
    console.log('Username:', review.username);
    console.log('User token в отзыве:', review.user_token);
    console.log('Текущий user token:', userToken);
    console.log('Совпадают?:', review.user_token === userToken);
    console.log('Device fingerprint в отзыве:', review.device_fingerprint);
    console.log('Текущий device fingerprint:', getDeviceFingerprint());
    console.log('========================');
}

function removeReviewFromUI(reviewId) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (reviewElement) {
        reviewElement.classList.add('fade-out');
        setTimeout(() => reviewElement.remove(), 300);
    }
}

// Функция проверки возможности редактирования
async function checkCanEditReview(reviewId) {
    try {
        const response = await fetch(`/api/reviews/${reviewId}/can_edit?user_token=${userToken}&device_fingerprint=${getDeviceFingerprint()}`);
        const data = await response.json();

        return data;
    } catch (error) {
        console.error('Error checking edit permission:', error);
        return { can_edit: false, reason: 'Ошибка проверки' };
    }
}

// Функция проверки времени удаления (6 часов)
function canDeleteReview(review) {
    try {
        const createdAt = new Date(review.created_at);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

        return hoursDiff <= 6;
    } catch (error) {
        console.error('Ошибка при проверке времени удаления:', error);
        return false;
    }
}

// Функция проверки времени редактирования (3 часа) - уже есть, оставляем
function canEditReview(review) {
    try {
        const createdAt = new Date(review.created_at);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);

        return hoursDiff <= 3;
    } catch (error) {
        console.error('Ошибка при проверке времени редактирования:', error);
        return false;
    }
}

// Функция обновления кнопок редактирования
function updateEditButtons() {
    reviews.forEach(review => {
        const canEdit = canEditReview(review);
        const reviewElement = document.querySelector(`.review-card[data-review-id="${review.id}"]`);

        if (reviewElement) {
            const editButton = reviewElement.querySelector('.edit-review-btn');
            if (editButton) {
                if (canEdit) {
                    editButton.style.display = 'block';
                    editButton.disabled = false;
                    editButton.title = 'Редактировать отзыв';
                } else {
                    editButton.style.display = 'none'; // или 'block' с другим стилем
                    editButton.disabled = true;
                    editButton.title = 'Время редактирования истекло (3 часа)';
                }
            }
        }
    });
}

// Функция обновления отображения звезд при редактировании
function updateEditStars(rating) {
    const stars = document.querySelectorAll('#edit-stars .star');
    stars.forEach((star, index) => {
        const starValue = index + 1;
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★" style="width:24px;height:24px;">`;
    });
}

// УСИЛЕННАЯ функция открытия модального окна редактирования
function openEditReviewModal(reviewId, currentRating, currentComment) {
    console.log('=== ПОПЫТКА ОТКРЫТИЯ РЕДАКТИРОВАНИЯ ===');

    const review = reviews.find(r => r.id == reviewId);
    if (!review) {
        return;
    }

    // ДВОЙНАЯ ПРОВЕРКА: Убеждаемся что пользователь автор
    if (!checkIsAuthor(review)) {
        console.log('Permission denied: user is not author');
        return;
    }

    // Дополнительная проверка времени
    if (!checkEditPermissionSync(review)) {
        console.log('Permission denied: edit time expired');
        return;
    }

    console.log('Opening edit modal for review:', { reviewId, currentRating, currentComment });

    const modal = document.getElementById('edit-review-modal');
    if (!modal) {
        console.error('Модальное окно редактирования не найдено');
        return;
    }

    // Сохраняем ID отзыва
    modal.dataset.reviewId = reviewId;
    document.getElementById('edit-review-id').value = reviewId;

    // Устанавливаем текущий рейтинг
    editRating = currentRating;
    updateEditStars(currentRating);

    // Устанавливаем комментарий
    document.getElementById('edit-comment').value = currentComment || '';

    // Устанавливаем токен пользователя
    document.getElementById('edit-user-token').value = userToken;

    // Показываем модальное окно
    modal.style.display = 'flex';

    console.log('Модальное окно редактирования открыто');
}

// Обработчик для формы редактирования
document.getElementById('edit-review-form').addEventListener('submit', async function(e) {
    e.preventDefault();

    const modal = document.getElementById('edit-review-modal');
    const reviewId = modal.dataset.reviewId;

    // Получаем рейтинг (количество заполненных звезд)
    const rating = modal.querySelectorAll('.star img[src*="baka.png"]').length;
    const comment = modal.querySelector('#edit-comment').value;

    try {
        const response = await fetch(`/api/reviews/${reviewId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                rating: rating,
                comment: comment,
                user_token: userToken,
                device_fingerprint: getDeviceFingerprint()
            })
        });

        const data = await response.json();

        if (response.ok) {
            closeEditModal();

            // Обновляем отзыв в локальном массиве
            const reviewIndex = reviews.findIndex(r => r.id == reviewId);
            if (reviewIndex !== -1) {
                reviews[reviewIndex].rating = rating;
                reviews[reviewIndex].comment = comment;
                reviews[reviewIndex].updated_at = new Date().toISOString();
            }

            // Перезагружаем отзывы и статистику
            loadReviews();
            initStats();
        } else {
        }
    } catch (error) {
    }
});

// Функция закрытия модального окна редактирования
function closeEditModal() {
    document.getElementById('edit-review-modal').style.display = 'none';
    editRating = 0;
}

// Таймер обратного отсчета
function startEditTimer(secondsLeft) {
    const timerElement = document.getElementById('edit-timer');
    if (!timerElement) {
        // Создаем элемент таймера если его нет
        const modalContent = document.querySelector('#edit-review-modal .modal-content');
        const timer = document.createElement('div');
        timer.id = 'edit-timer';
        timer.style.cssText = 'text-align: center; margin: 10px 0; color: #666; font-size: 14px;';
        modalContent.insertBefore(timer, modalContent.querySelector('form'));
    }

    let timeLeft = secondsLeft;

    const timerInterval = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            document.getElementById('edit-timer').textContent = 'Время вышло!';
            document.querySelector('#edit-review-form button').disabled = true;
            return;
        }

        const hours = Math.floor(timeLeft / 3600);
        const minutes = Math.floor((timeLeft % 3600) / 60);
        const seconds = Math.floor(timeLeft % 60);

        document.getElementById('edit-timer').textContent =
            `Осталось времени: ${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        timeLeft--;
    }, 1000);
}

// Функция отправки изменений
async function submitEditReview(e) {
    if (e) e.preventDefault();

    console.log('=== НАЧАЛО ОБРАБОТКИ СОХРАНЕНИЯ ОТЗЫВА ===');

    const modal = document.getElementById('edit-review-modal');
    const reviewId = modal.dataset.reviewId;
    const comment = document.getElementById('edit-comment').value.trim();

    if (!reviewId) {
        return;
    }

    if (editRating === 0) {
        return;
    }

    console.log('Данные для сохранения:', {
        reviewId: reviewId,
        rating: editRating,
        comment: comment
    });

    const requestData = {
        rating: editRating,
        comment: comment,
        user_token: userToken,
        device_fingerprint: getDeviceFingerprint()
    };

    try {
        showLoadingIndicator();

        const response = await fetch(`/api/reviews/${reviewId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });

        const data = await response.json();
        console.log('Ответ сервера:', response.status, data);

        if (response.ok) {
            closeEditModal();

            // ВАЖНО: Используем данные из ответа сервера, а не локальные переменные
            if (data.review) {
                console.log('Данные из сервера:', data.review);

                // ОБНОВЛЯЕМ ГЛОБАЛЬНЫЙ МАССИВ ОТЗЫВОВ С ВСЕМИ ПОЛЯМИ
                updateReviewData(reviewId, data.review);

                // НЕМЕДЛЕННО ОБНОВЛЯЕМ UI БЕЗ ОЖИДАНИЯ
                updateReviewInUI(reviewId, data.review);

                // Дополнительно: обновляем статистику
                setTimeout(() => {
                    initStats();
                }, 100);
            }

        } else {
            throw new Error(data.error || `Ошибка сервера: ${response.status}`);
        }

    } catch (error) {
        console.error('Ошибка при сохранении:', error);
    } finally {
        hideLoadingIndicator();
    }
}

// Функция для полного пересоздания элемента отзыва
function refreshReviewElement(reviewId, newRating) {
    const reviewElement = document.querySelector(`.review-card[data-review-id="${reviewId}"]`);
    if (!reviewElement) return;

    // Находим отзыв в массиве
    const reviewIndex = reviews.findIndex(r => r.id == reviewId);
    if (reviewIndex === -1) return;

    // Обновляем рейтинг в данных
    reviews[reviewIndex].rating = newRating;

    // Полностью пересоздаем элемент
    const newReviewElement = createReviewElement(reviews[reviewIndex]);

    // Заменяем старый элемент новым
    reviewElement.parentNode.replaceChild(newReviewElement, reviewElement);

    console.log('Элемент отзыва полностью обновлен с рейтингом:', newRating);
}

// Функция установки рейтинга при редактировании
function setEditRating(rating) {
    editRating = rating;

    // Обновляем отображение звезд - ИСПРАВЛЯЕМ ПУТИ!
    const stars = document.querySelectorAll('#edit-stars .star');
    stars.forEach((star, index) => {
        const starValue = index + 1;
        // ИСПРАВЛЯЕМ: используем правильные пути из PATHS
        const starImage = starValue <= rating ? PATHS.starActive : PATHS.starInactive;
        star.innerHTML = `<img src="${starImage}" alt="★" style="width:24px;height:24px;">`;
    });

    console.log('Установлен рейтинг:', rating);
}

function closeEditReviewModal() {
    document.getElementById('edit-review-modal').style.display = 'none';
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    // Установка текущего пользователя (должно приходить из системы авторизации)
    currentUser = 1; // Здесь должен быть ID текущего пользователя

    // Загрузка данных ресторана
    loadRestaurantData();

    // Обработчики для модального окна редактирования отзыва
    document.getElementById('edit-review-form').addEventListener('submit', function(e) {
        e.preventDefault();

        const reviewId = this.dataset.reviewId;
        const rating = this.querySelectorAll('.star.filled').length;
        const comment = this.querySelector('textarea').value;

        closeEditReviewModal();
    });

    // Закрытие модальных окон при клике вне их
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                if (this.id === 'review-modal') closeReviewModal();
                if (this.id === 'edit-review-modal') closeEditReviewModal();
            }
        });
    });
});

        // Функция для отладки системы оценок
// Улучшенная функция для отладки системы оценок
function debugRatingSystem(reviewId) {
    console.log('=== ДЕБАГ СИСТЕМЫ ОЦЕНОК ===');
    const review = reviews.find(r => r.id == reviewId);
    if (review) {
        console.log('Отзыв:', {
            id: review.id,
            username: review.username,
            likes: review.likes,
            dislikes: review.dislikes,
            user_ratings: review.user_ratings,
            current_user_rating: review.user_ratings?.[userToken]
        });
    } else {
        console.log('Отзыв не найден в глобальном массиве');
    }
    console.log('Текущий userToken:', userToken);
    console.log('Все отзывы в массиве:', reviews.map(r => ({id: r.id, rating: r.rating})));
    console.log('============================');
}
</script>
</body>
</html>